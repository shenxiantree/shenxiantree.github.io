{"meta":{"title":"ShenXianTree","subtitle":"许愿树の博客","description":"本科 | 软件工程 | Java后端","author":"Luckey","url":"https://shenxiantree.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://shenxiantree.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-02-02T03:58:56.489Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://shenxiantree.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"","date":"2022-02-02T03:58:56.482Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://shenxiantree.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://shenxiantree.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"about/index.html","permalink":"https://shenxiantree.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"categories/index.html","permalink":"https://shenxiantree.github.io/categories/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"https://shenxiantree.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-02-01T16:00:00.000Z","updated":"2022-02-02T05:39:01.594Z","comments":true,"path":"contact/index.html","permalink":"https://shenxiantree.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: 神仙树の博客 博客网址: https://shenxiantree.github.io/ 博客头像: https://p2.ssl.qhimgs1.com/sdr/400__/t0185dc54c8f41cf19c.jpg 博客介绍: The harder you work, the luckier you will be"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"archives/index.html","permalink":"https://shenxiantree.github.io/archives/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"https://shenxiantree.github.io/resource/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"friends/index.html","permalink":"https://shenxiantree.github.io/friends/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-02-02T03:58:56.240Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"https://shenxiantree.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"tags/index.html","permalink":"https://shenxiantree.github.io/tags/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"https://shenxiantree.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"https://shenxiantree.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://shenxiantree.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-02-02T03:58:56.249Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-02-02T03:58:56.241Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-02-02T03:58:56.252Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-02-02T03:58:56.253Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-02-02T03:58:56.255Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-02-02T03:58:56.257Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-02-02T03:58:56.261Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-02-02T03:58:56.262Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-02-02T03:58:56.264Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-02-02T03:58:56.264Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-02-02T03:58:56.267Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-02-02T03:58:56.268Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://shenxiantree.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"整合SSM配置文件","date":"2022-10-23T10:35:00.517Z","updated":"2022-10-23T10:16:03.042Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"配置依赖&lt;!-- Spring MVC--> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-webmvc&lt;/artifactId> &lt;version>5.3.20&lt;/version> &lt;/dependency> &lt;!-- 事务--> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-tx&lt;/artifactId> &lt;version>5.3.20&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-jdbc&lt;/artifactId> &lt;version>5.3.20&lt;/version> &lt;/dependency> &lt;!-- aop --> &lt;!--这两个包不属于Spring自身jar包，他们属于AspectJ技术--> &lt;dependency> &lt;groupId>org.aspectj&lt;/groupId> &lt;artifactId>aspectjweaver&lt;/artifactId> &lt;version>1.9.4&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.aspectj&lt;/groupId> &lt;artifactId>aspectjrt&lt;/artifactId> &lt;version>1.9.4&lt;/version> &lt;/dependency> &lt;!--MyBatis 核心包--> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.10&lt;/version> &lt;/dependency> &lt;!--mysql驱动--> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.11&lt;/version> &lt;/dependency> &lt;!--spring 整合mybatis--> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis-spring&lt;/artifactId> &lt;version> 2.0.5&lt;/version> &lt;/dependency> &lt;!--单元测试相关依赖--> &lt;!--单元测试--> &lt;dependency> &lt;groupId>org.junit.jupiter&lt;/groupId> &lt;artifactId>junit-jupiter-api&lt;/artifactId> &lt;version>5.9.0&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-test&lt;/artifactId> &lt;version>5.3.20&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> applicationContext.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!--扫描Service实现类--> &lt;context:component-scan base-package=\"com.xja.service\"/> &lt;!-- 1. 创建数据源 --> &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/> &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"> &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/> &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/> &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/> &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/> &lt;/bean> &lt;!-- 2. 为了创建Dao代理对象，先创建SqlSessionFactory对象 --> &lt;!-- SqlSessionFactoryBean: 创建SqlSessionFactory对象的工具 --> &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> &lt;!--指定Mybatis配置文件位置--> &lt;!-- &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\">&lt;/property> --> &lt;!-- 注入数据源 --> &lt;property name=\"dataSource\" ref=\"dataSource\"/> &lt;property name=\"typeAliasesPackage\" value=\"com.xja.entity\"/> &lt;!-- mybatis配置自动识别驼峰--> &lt;property name=\"configuration\"> &lt;bean class=\"org.apache.ibatis.session.Configuration\"> &lt;property name=\"mapUnderscoreToCamelCase\" value=\"true\"/> &lt;/bean> &lt;/property> &lt;!-- 配置mapper文件位置，扫描映射文件--> &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"> &lt;/property> &lt;/bean> &lt;!-- 3. 扫描Dao接口所在包，扫描后用于创建Dao代理对象，把代理对象放入IOC容器 --> &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"> &lt;!-- Dao扫描目录 --> &lt;property name=\"basePackage\" value=\"com.xja.dao\"/> &lt;/bean> &lt;/beans> springMVC.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"> &lt;!-- 1.扫描控制器 --> &lt;context:component-scan base-package=\"com.xja.controller\"/> &lt;!-- 2.视图解析器 --> &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;property name=\"prefix\" value=\"/pages/\"/> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> &lt;!-- 3.创建处理器映射器和处理器适配器 --> &lt;mvc:annotation-driven/> &lt;/beans> web.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"> &lt;!-- 配置核心控制器 --> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc.xml&lt;/param-value> &lt;/init-param> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;!-- 配置spring监听器，用于加载applicationContext.xml（初始化SpringIOC容器） --> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:applicationContext.xml&lt;/param-value> &lt;/context-param> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> &lt;/web-app>","categories":[],"tags":[]},{"title":"","slug":"一、Spring Security入门","date":"2022-10-23T10:35:00.512Z","updated":"2022-10-23T10:20:33.386Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"Spring Security 是一种高度自定义的安全框架，利用（基于）SpringIOC/DI和AOP功能，为系统提供了声明式安全访问控制功能，「减少了为系统安全而编写大量重复代码的工作」 。核心工作：认证和授权 Spring Security 认证流程 1、项目搭建&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-security&lt;/artifactId> &lt;/dependency> 访问页面：导入spring-boot-starter-security启动器后，Spring Security已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。在浏览器输入：http://localhost:8080/ 进入Spring Security内置登录页面用户名：user。密码：项目启动，打印在控制台中。 测试：创建controller： @RestController public class HelloController &#123; @GetMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125; &#125; 启动项目访问：http://localhost:8080/hello自定义用户名和密码：修改application.yml配置文件： # 静态用户，一般只在内部网络认证中使用，如：内部服务器1，访问服务器2 spring: security: user: name: test # 通过配置文件，设置静态用户名 password: test # 配置文件，设置静态登录密码 roles: admin","categories":[],"tags":[]},{"title":"","slug":"五、Ribbon学习","date":"2022-10-23T10:35:00.508Z","updated":"2022-10-23T10:21:59.410Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"Ribbon是Netflix发布的负载均衡器，它有助于控制HTTP和TCP客户端的行为。为Ribbon配置服务提供者地址列表后，Ribbon就可以基于某种均衡算法，自动帮助服务消费者去请求。Ribbon默认提供了很多负载均衡算法，如：轮询、随机、hash等，也可以为Ribbon实现自定义的负载均衡算法。 一、复制项目microservice-consumer-movie,将artifactId修改为microservice-consumer-movie-ribbon整合自行解决 二、引入依赖&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> 为RestTemplate添加@LoadBalanced注解，就可以为 RestTemplate整合Ribbon，使其具备负载均衡的能力。 @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); //默认使用URLConnection &#125; Ribbon默认的负载方式是轮询 修改controller代码 @RestController @RequestMapping(\"/consumer\") @Slf4j public class MovieController &#123; @Resource private RestTemplate restTemplate; @Resource private LoadBalancerClient loadBalancerClient; @GetMapping(\"/user/&#123;id&#125;\") public User findById(@PathVariable Integer id) &#123; return restTemplate.getForObject(\"http://user-provider/user/\" + id, User.class); &#125; @GetMapping(\"/logUserInstance\") public void logUserInstance()&#123; ServiceInstance serviceInstance=loadBalancerClient.choose(\"user-provider\"); //打印当前选择的是哪个结点 log.info(\"&#123;&#125;:&#123;&#125;:&#123;&#125;\",serviceInstance.getServiceId(),serviceInstance.getHost(),serviceInstance.getPort()); &#125; &#125; 测试步骤： | 先启动注册中心Eureka-server然后启动两个提供者microservice-provider-userjava -jar microservice-provider-user-1.0-SNAPSHOT.jarjava -Dserver.port=9999 -jar microservice-provider-user-1.0-SNAPSHOT.jar注意：服务提供者使用单机注册中心，不是集群然后启动服务消费者访问controller 进行测试（microservice-consumer-moive-ribbon） || — | 三、自定义配置使用Java代码自定义Ribbon的配置@Configuration public class RibbonConfig &#123; @Bean public IRule ribbonRule()&#123; //负载均衡规则，改为随机 return new RandomRule(); &#125; &#125; /** * 使用@RibbonClient注解的configuration属性，即可自定义指定名称Ribbon客户端配置 */ @Configuration @RibbonClient(name=\"user-provider\",configuration = RibbonConfig.class) public class RibbonClientConfig &#123; &#125; 启动服务测试 | 启动注册中心启动至少两个服务提供者（microservice-provider-user）java -jar microservice-provider-user-1.0-SNAPSHOT.jarjava -Dserver.port=9999 -jar microservice-provider-user-1.0-SNAPSHOT.jar注意：服务提供者使用单机注册中心，不是集群然后启动服务消费者（microservice-consumer-moive-ribbon-custom）访问controller 进行测试 || — | 使用属性自定义Ribbon的配置配置application.yml #将服务提供者 user-provider的Ribbon Client 的负载均衡规则为随机规则 user-provider: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #若配置成以下形式，则表示对所有的Ribbon Client 都使用RandomRule #ribbon: # NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 测试： | 启动注册中心启动至少两个服务提供者（microservice-provider-user）java -jar microservice-provider-user-1.0-SNAPSHOT.jarjava -Dserver.port=9999 -jar microservice-provider-user-1.0-SNAPSHOT.jar注意：服务提供者使用单机注册中心，不是集群然后启动服务消费者（microservice-consumer-moive-ribbon-custom）访问controller 进行测试 || — | 脱离Eureka使用Ribbonpom文件修改 &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-ribbon&lt;/artifactId> &lt;/dependency> application.yml 修改 spring: application: name: consumer-movie #将服务提供者 user-provider的Ribbon Client 的负载均衡规则为随机规则 # listOfServers 用于名为user-provider的ribbon客户端设置请求的地址列表 user-provider: ribbon: # 然后listOfServers上配置两个服务 listOfServers: localhost:8888,localhost:9999 NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule","categories":[],"tags":[]},{"title":"","slug":"四、Spring Security 注解","date":"2022-10-23T10:35:00.504Z","updated":"2022-10-23T10:20:24.310Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"@Secured| ❝角色校验 ,请求到来访问控制单元方法时必须包含XX角色才能访问角色必须添加ROLE_前缀❞ || — | @Secured(&#123;\"ROLE_管理员\",\"ROLE_访客\"&#125;) @RequestMapping(\"/toMain\") public String toMain()&#123; return \"main\"; &#125; 使用注解@Secured需要在配置类中添加注解 使@Secured注解生效 @EnableGlobalMethodSecurity(securedEnabled = true) @PreAuthorize| ❝权限检验,请求到来访问控制单元之前必须包含xx权限才能访问，控制单元方法执行前进行角色校验❞ || — | /** * [ROLE_管理员, admin:read, admin:write, all:login, all:logout, all:error, all:toMain] * @PreAuthorize 角色 、权限 校验 方法执行前进行角色校验 * * hasAnyAuthority() * hasAuthority() * * hasPermission() * * * hasRole() * hasAnyRole() * */ @PreAuthorize(\"hasAnyRole('ROLE_管理员','ROLE_访客')\") @RequestMapping(\"/toMain\") @PreAuthorize(\"hasAuthority('admin:write')\") public String toMain()&#123; return \"main\"; &#125; 使用@PreAuthorize和@PostAuthorize 需要在配置类中配置注解@EnableGlobalMethodSecurity 才能生效 @EnableGlobalMethodSecurity(prePostEnabled = true) @PostAuthorize| ❝权限检验,请求到来访问控制单元之后必须包含xx权限才能访问 ，控制单元方法执行完后进行角色校验❞ || — | /** * [ROLE_管理员, admin:read, admin:write, all:login, all:logout, all:error, all:toMain] * @PostAuthorize 角色 、权限 校验 方法执行后进行角色校验 * * hasAnyAuthority() * hasAuthority() * hasPermission() * hasRole() * hasAnyRole() * */ @PostAuthorize(\"hasRole('ROLE_管理员')\") @RequestMapping(\"/toMain\") @PreAuthorize(\"hasAuthority('admin:write')\") public String toMain()&#123; return \"main\"; &#125; Spring Security 整合Thymeleaf 进行权限校验&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.thymeleaf.extras&lt;/groupId> &lt;artifactId>thymeleaf-extras-springsecurity5&lt;/artifactId> &lt;/dependency>","categories":[],"tags":[]},{"title":"","slug":"四、Eureka Server的HA(高可用)","date":"2022-10-23T10:35:00.499Z","updated":"2022-10-23T10:21:51.523Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"如果只配置一台注册中心（Eureka Server），就会出现SPOF(单点故障)，如果Eureka Server发生宕机，就会影响注册到Eureka Server上的微服务，导致微服务不可用。所以在生产环境中，通常会部署一个高可用的Eureka Server 集群。架构图如下： 编写高可用Eureka Server复制项目eureka-server 改为eureka-server-peer2. 配置系统的hostsØ Windows系统下的hosts文件路径是：C:\\Windows\\System32\\drivers\\etc\\hostsØ Linux及Mac OS等系统的文件路径是：/etc/hosts 127.0.0.1 peer1 peer2 （由于本人太懒，没有修改hosts，ip地址直接使用127.0.0.1也行） 修改application-peer1.ymlspring: profiles: peer1 server: port: 8761 # 指定该Eureka实例的端口 eureka: instance: #指定profile=peer1 时，主机名是peer1 hostname: peer1 client: serviceUrl: #将自己注册到peer2这个Eureka上面 defaultZone: http://127.0.0.1:8762/eureka/ 修改application-peer2.ymlspring: profiles: peer2 server: port: 8762 # 指定该Eureka实例的端口 eureka: instance: #指定profile=peer1 时，主机名是peer1 hostname: peer2 client: serviceUrl: #将自己注册到peer2这个Eureka上面 defaultZone: http://127.0.0.1:8761/eureka/ 运行maven命令打包打包完成的路径：进入控制台，使用命令编译运行： | java -jar D:\\学佳澳\\workspace\\springcloud-test\\eureka-server-peer\\target\\eureka-server-peer-1.0-SNAPSHOT.jar –spring.profiles.active=peer1 java -jar D:\\学佳澳\\workspace\\springcloud-test\\eureka-server-peer\\target\\eureka-server-peer-1.0-SNAPSHOT.jar –spring.profiles.active=peer2|| — | 注意：启动第一台eureka-server时，console上会报错，因为它注册不到peer2Peer2 还没有启动 将应用注册到Eureka Server 集群上修改客户端microservice-provider-user，让客户端同时注册到多个注册中心。client/application.yml eureka: client: service-url: defaultZone: http://peer1:8761/eureka/,http://peer2:8762/eureka/ # 注意用逗号分开 # defaultZone: http://localhost:8761/eureka/ # instance: # prefer-ip-address: true 启动客户端 用户认证为Eureka Server 添加用户认证将eureka-server项目复制一份eureka-server-security修改pom文件中artifactId使用idea 打开工程eureka-server-security eureka-server-security/pom.xml 加入安全依赖spring-boot-starter-security，该依赖为Eureka server提供用户认证的能力。 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-security&lt;/artifactId> &lt;/dependency> 修改工程eureka-server-security下的application.yml，添加以下内容 spring: security: user: name: user password: 123456 修改application.yml中eureka.client.serviceUrl. defaultZone 为http://user:123456@localhost:8761/eureka/edu.xja.config包下添加web配置信息类 @EnableWebSecurity public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter &#123; /** * 高版本springcloud的丢弃了配置: * * security: * basic: * enabled: true * * 所以应该使用以下方式开启 * * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable(); //注意：为了可以使用 http://$&#123;user&#125;:$&#123;password&#125;@$&#123;host&#125;:$&#123;port&#125;/eureka/ 这种方式登录,所以必须是httpBasic, // 如果是form方式,不能使用url格式登录 http.authorizeRequests().anyRequest().authenticated().and().httpBasic(); &#125; &#125; 启动测试 将微服务注册到需认证的Eureka Server修改microservice-provider-user下的application.yml eureka: client: service-url: defaultZone: http://user:123456@localhost:8761/eureka/ 测试：","categories":[],"tags":[]},{"title":"","slug":"十一、Gateway（网关）","date":"2022-10-23T10:35:00.495Z","updated":"2022-10-23T10:22:36.387Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"一、简介Spring Cloud Gateway是 Spring官方基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor等技术开发的网关。其目标是替代Netflix Zuul，它不仅提供统一的路由方式，并且基于Filter 链的方式提供了网关基本的功能。Spring Cloud Gateway依赖 Spring Boot 和 Spring WebFlux，基于Netty运行。它不能在传统的 servlet 容器中工作，也不能构建成 war 包。 二、工作原理Spring Cloud Gateway 的工作理跟Zuul的差不多，最大的区别就是 Gateway的Filter 只有pre 和 post 两种。下面我们简单了解一下 Gateway 的工作原理图，如下图所示。客户端向Spring Cloud Gateway 发出请求，如果请求与网关程序定义的路由匹配，则该请求就会被发送到网关 Web 处理程序，此时处理程序运行特定的请求过滤器链。过滤器之间用虚线分开的原因是过滤器可能会在发送代理请求的前后执行逻辑。所有pre 过滤器逻辑先执行，然后执行代理请求；代理请求完成后，执行post过滤器逻辑。 三、创建Gateway基础项目新建spring boot项目 添加依赖&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> 在yml文件中配置路由spring: application: name: gateway-program cloud: gateway: routes: - id: path_route uri: lb://user-application predicates: - Path=/demo/** #StripPrefix=1 就代表截取路径的个数为1，这样配置后当请求/demo/user/21后端匹配到的请求路径， #为 http://localhost:9999/user/21 filters: StripPrefix=1 server: port: 9999 路由断言工厂的使用1、Path路由断言工厂spring: cloud: gateway: routes: - id: path_route uri: https://example.org predicates: - Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125; 如果请求路径/red/1 or /red/1/ or /red/blue or /blue/green. 则路由可以匹配 2、Query路由断言工厂Query路由断言工厂接收两个参数，一个必须的参数和一个可选的正则表达式。 spring: cloud: gateway: routes: - id: query_route uri: https://example.org predicates: - Query=red, gree. 如果请求包含一个请求参数，参数名为red，参数值为gree开头的五个字符的单词，则此路由将匹配。 3、Method路由断言工厂Method路由断言工厂接收一个参数，即要匹配HTTP方法。 spring: cloud: gateway: routes: - id: method_route uri: https://example.org predicates: - Method=GET,POST 4、Header路由断言工厂Header路由断言工厂接收两个参数，分别是请求头名称和正则表达式。 spring: cloud: gateway: routes: - id: header_route uri: https://example.org predicates: - Header=X-Request-Id, \\d+ 如果请求中带有请求头X-Request-Id，其值与\\d+正则表达式匹配（值为1个或者多个数字），则此路由匹配。 5、后路由断言工厂（The After Route Predicate Factory）后路由断言工厂接受一个参数，即日期时间（即javaZaned日期时间）。此谓词匹配在指定的日期时间之后发生的请求。 spring: cloud: gateway: routes: - id: after_route uri: https://example.org predicates: - After=2017-01-20T17:42:47.789-07:00[America/Denver] 6、前路由断言工厂（The Before Route Predicate Factory）路由之前断言工厂接受一个参数，即日期时间（即javaZoned日期时间）。此谓词匹配在指定的日期时间之前发生的请求。 spring: cloud: gateway: routes: - id: before_route uri: https://example.org predicates: - Before=2017-01-20T17:42:47.789-07:00[America/Denver] 7、路由间断言工厂此谓词匹配在日期时间1之后和日期时间2之前发生的请求。日期时间2的参数必须是在日期时间1之后。 spring: cloud: gateway: routes: - id: between_route uri: https://example.org predicates: - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver] 8、请求头断言工厂请求头断言工厂接受两个参数，头名称和一个regexp（这是一个Java正则表达式）。此谓词与其值与正则表达式匹配的标头匹配。 spring: cloud: gateway: routes: - id: header_route uri: https://example.org predicates: - Header=X-Request-Id, \\d+ 四、整合Eurake添加依赖&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> 配置基于Eurake的路由spring: application: name: gateway-program cloud: gateway: discovery: locator: enabled: true routes: - id: path_route uri: lb://user-application predicates: - Path=/demo/** #StripPrefix=1 就代表截取路径的个数为1，这样配置后当请求/demo/user/21后端匹配到的请求路径， #为 http://localhost:9999/user/21 filters: StripPrefix=1 server: port: 9999 uri以lb://开发（lb代表从注册中心获取服务），后面接的就是你需要转发到的服务名称，这个服务名称必须跟Eureka中的对应，否则会找不到服务。 服务名称大小写问题spring: cloud: gateway: discovery: locator: lower-case-service-id: true 注意：开启小写服务名称后大写的服务名称就不能使用，两者只能选其一。配置源码在org.springframework.cloud.gateway.discovery.DiscoveryLocatorProperties中，如下是部分代码 五、整合Nacos添加依赖&lt;!--使用nacos作为注册中心--> &lt;dependency> &lt;groupId>com.alibaba.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId> &lt;version>2.2.6.RELEASE&lt;/version> &lt;/dependency> 配置路由spring: cloud: #配置网关的路由 gateway: discovery: locator: enabled: true lower-case-service-id: true routes: - id: member_route uri: \"lb://springboot1\" predicates: - Path=/** - id: order_route uri: \"lb://film-order\" predicates: - Path=/** uri以lb://开发（lb代表从注册中心获取服务），后面接的就是你需要转发到的服务名称，这个服务名称必须跟Nacos中的对应，否则会找不到服务。 将网关注册到nacos注册中心spring: cloud: #将网关注册到注册中心nacos nacos: discovery: namespace: 8b15a8a7-8237-4ff6-a28e-ac949e399a1f group: THOMAS_GROUP server-addr: 127.0.0.1:8848 整合Consul新建Gateway网关工程添加Spring Cloud Gateway、Spring Cloud Consul依赖，如下： &lt;!-- gateway 依赖 --> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-gateway&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-consul-discovery&lt;/artifactId> &lt;/dependency> 添加配置server: port: 9999 spring: application: name: gateway-consul cloud: gateway: discovery: locator: enabled: true consul: host: localhost port: 8500 整合后的访问路径： http://网关地址:端口/服务中心serviceId/方法 测试启动consul参见：e:/consul.exe启动服务提供者参见D:\\xja-workspace\\spring-cloud-learn1\\consul-provider-learn1启动网关工程参见：D:\\xja-workspace\\spring-cloud-learn1\\spring-cloud-gateway-learn2 六、过滤器工厂1、AddRequestHeader过滤器工厂通过名称我们可以理解这个过滤器工厂的作用是添加请求头 spring: cloud: gateway: routes: - id: add_request_header_route uri: https://example.org filters: - AddRequestHeader=X-Request-red, blue 2、RemoveRequestHeader过滤器工厂这个过滤器工厂的作用是移除请求头，可以在请求转发到后端服务之前进行Header的移除操作 spring: cloud: gateway: routes: - id: removerequestheader_route uri: https://example.org filters: - RemoveRequestHeader=X-Request-Foo 3、SetResponseHeader过滤器工厂这个过滤器工厂的作用是设置响应头 spring: cloud: gateway: routes: - id: setresponseheader_route uri: https://example.org filters: - SetResponseHeader=X-Response-Red, Blue 七、加入跨域请求前后端分离时，为了使gateway能够支持前端访问，需要加入支持前端访问的跨域请求。参考代码： @Configuration public class CorsConfig &#123; @Bean public CorsWebFilter corsFilter() &#123; CorsConfiguration config = new CorsConfiguration(); config.addAllowedMethod(\"*\"); config.addAllowedOrigin(\"*\"); config.addAllowedHeader(\"*\"); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser()); source.registerCorsConfiguration(\"/**\", config); return new CorsWebFilter(source); &#125; &#125; 八、自定义过滤器自定义全局过滤器需要实现以下两个接口:GlobalFilter,ordered。通过全局过滤器可以实现权限校验，安全性验证等功能。 @Component @Slf4j public class RequestLogGlobalFilter implements GlobalFilter, Ordered &#123; /** * @param exchange 网络交换机 * @param chain 过滤器链 * @return 过滤器链 */ @Override public Mono&lt;Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; // 获取请求路径 URI uri = exchange.getRequest().getURI(); log.info(\"获取到请求路径：&#123;&#125;\", uri.toString()); log.info(\"error\"); return chain.filter(exchange); &#125; /** * 设置过滤器执行顺序，数值越低，优先级越高 * * @return */ @Override public int getOrder() &#123; return -50; &#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"三、登录配置、角色管理","date":"2022-10-23T10:35:00.492Z","updated":"2022-10-23T10:20:16.553Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1、登录配置1.1、方式一：转发http.formLogin() .usernameParameter(\"name\") // 设置请求参数中，用户名参数名称。 默认username .passwordParameter(\"pswd\") // 设置请求参数中，密码参数名称。 默认password .loginPage(\"/toLogin\") // 当用户未登录的时候，跳转的登录页面地址是什么？ 默认 /login .loginProcessingUrl(\"/login\") // 用户登录逻辑请求地址是什么。 默认是 /login .failureForwardUrl(\"/failure\"); // 登录失败后，请求转发的位置。Security请求转发使用Post请求。默认转发到：loginPage?error .successForwardUrl(\"/toMain\"); // 用户登录成功后，请求转发到的位置。Security请求转发使用POST请求。 1.2、方式二：重定向http.formLogin() .usernameParameter(\"name\") // 设置请求参数中，用户名参数名称。 默认username .passwordParameter(\"pswd\") // 设置请求参数中，密码参数名称。 默认password .loginPage(\"/toLogin\") // 当用户未登录的时候，跳转的登录页面地址是什么？ 默认 /login .loginProcessingUrl(\"/login\") // 用户登录逻辑请求地址是什么。 默认是 /login .defaultSuccessUrl(\"/toMain\",true); //用户登录成功后，响应重定向到的位置。GET请求。必须配置绝对地址。 .failureUrl(\"/failure\"); // 登录失败后，重定向的位置。 1.3、自定义登录处理器自定义登录失败逻辑处理器： /*自定义登录失败处理器*/ public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; private String url; private boolean isRedirect; public MyAuthenticationFailureHandler(String url, boolean isRedirect) &#123; this.url = url; this.isRedirect = isRedirect; &#125; @Override public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; if (isRedirect)&#123; httpServletResponse.sendRedirect(url); &#125;else &#123; httpServletRequest.getRequestDispatcher(url).forward(httpServletRequest,httpServletResponse); &#125; &#125; //get set 方法 省略 自定义登录成功逻辑处理器： /** * 自定义登录成功后处理器 * 转发重定向，有代码逻辑实现 * */ public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; private String url; private boolean isRedirect; public MyAuthenticationSuccessHandler(String url, boolean isRedirect) &#123; this.url = url; this.isRedirect = isRedirect; &#125; /** * @param request 请求对象 request.getRequestDispatcher.forward() * @param response 响应对象 response.sendRedirect() * @param authentication 用户认证成功后的对象。其中报换用户名权限结合，内容是 * 自定义UserDetailsService * */ @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; if (isRedirect)&#123; response.sendRedirect(url); &#125;else &#123; request.getRequestDispatcher(url).forward(request,response); &#125; &#125; //get set 方法 省略 http.formLogin() .usernameParameter(\"name\") // 设置请求参数中，用户名参数名称。 默认username .passwordParameter(\"pswd\") // 设置请求参数中，密码参数名称。 默认password .loginPage(\"/toLogin\") // 当用户未登录的时候，跳转的登录页面地址是什么？ 默认 /login .loginProcessingUrl(\"/login\") // 用户登录逻辑请求地址是什么。 默认是 /login 1.4、登录相关配置类@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private UserSecurity userSecurity; @Autowired private PersistentTokenRepository persistentTokenRepository; /** * 加密 * @return 加密对象 * 如需使用自定义加密逻辑 返回自定义加密对象 * return new MD5PasswordEncoder(); return new SimplePasswordEncoder(); */ @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); //Spring Security 自带 &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; // 配置登录请求相关内容。 http.formLogin() .loginPage(\"/toLogin\") // 当用户未登录的时候，跳转的登录页面地址是什么？ 默认 /login .usernameParameter(\"name\") // 设置请求参数中，用户名参数名称。 默认username .passwordParameter(\"pswd\") // 设置请求参数中，密码参数名称。 默认password .loginProcessingUrl(\"/login\") //设置登录 提交表单数据访问请求地址 .defaultSuccessUrl(\"/toMain\") .failureUrl(\"/toLogin\"); //.successForwardUrl(\"/toMain\") //.failureForwardUrl(\"/toLogin\"); //.successHandler(new LoginSuccessHandler(\"/toMain\", true)) //自定义登录成功处理器 //.failureHandler(new LoginErrorHandler(\"/toLogin\", true)); http.authorizeRequests() //.antMatchers(\"/toLogin\").anonymous() //只能匿名用户访问 .antMatchers(\"/toLogin\", \"/register\", \"/login\", \"/favicon.ico\").permitAll() // /toLogin请求地址，可以随便访问。 .antMatchers(\"/**/*.js\").permitAll() // 授予所有目录下的所有.js文件可访问权限 .regexMatchers(\".*[.]css\").permitAll() // 授予所有目录下的所有.css文件可访问权限 .anyRequest().authenticated(); // 任意的请求，都必须认证后才能访问。 // 配置退出登录 http.logout() .invalidateHttpSession(true) // 回收HttpSession对象。退出之前调用HttpSession.invalidate() 默认 true .clearAuthentication(true) // 退出之前，清空Security记录的用户登录标记。 默认 true // .addLogoutHandler() // 增加退出处理器。 .logoutSuccessUrl(\"/\") // 配置退出后，进入的请求地址。 默认是loginPage?logout .logoutUrl(\"/logout\"); // 配置退出登录的路径地址。和页面请求地址一致即可。 // 关闭CSRF安全协议。 // 关闭是为了保证完整流程的可用。 http.csrf().disable(); &#125; @Bean public PersistentTokenRepository persistentTokenRepository(DataSource dataSource)&#123; JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); //jdbcTokenRepository.setCreateTableOnStartup(true); return jdbcTokenRepository; &#125; &#125; 2、角色管理「hasAuthority(String)」 判断角色是否具有特定权限 http.authorizeRequests().antMatchers(\"/main1.html\").hasAuthority(\"admin\") 「hasAnyAuthority(String …)」 如果用户具备给定权限中某一个，就允许访问 http.authorizeRequests().antMatchers(\"/admin/read\").hasAnyAuthority(\"xxx\",\"xxx\") 「hasRole(String)」 如果用户具备给定角色就允许访问。否则出现403 //请求地址为/admin/read的请求，必须登录用户拥有'管理员'角色才可访问 http.authorizeRequests().antMatchers(\"/admin/read\").hasRole(\"管理员\") 「hasAnyRole(String …)」 如果用户具备给定角色的任意一个，就允许被访问 //用户拥有角色是管理员 或 访客 可以访问 /guest/read http.authorizeRequests().antMatchers(\"/guest/read\").hasAnyRole(\"管理员\", \"访客\") 「hasIpAddress(String)」 请求是指定的IP就运行访问 //ip 是127.0.0.1 的请求 可以访问/ip http.authorizeRequests().antMatchers(\"/ip\").hasIpAddress(\"127.0.0.1\") 3、权限不足页面处理3.1、编写类实现接口「AccessDeniedHandler」/** * @describe 403 权限不足 * @author: AnyWhere * @date 2021/4/18 20:57 */ @Component public class MyAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException &#123; response.setStatus(HttpServletResponse.SC_OK); response.setContentType(\"text/html;charset=UTF-8\"); response.getWriter().write( \"&lt;html>\" + \"&lt;body>\" + \"&lt;div style='width:800px;text-align:center;margin:auto;font-size:24px'>\" + \"权限不足，请联系管理员\" + \"&lt;/div>\" + \"&lt;/body>\" + \"&lt;/html>\" ); response.getWriter().flush();//刷新缓冲区 &#125; &#125; 3.2、配置类中配置exceptionHandling// 配置403访问错误处理器。 http.exceptionHandling().accessDeniedHandler(myAccessDeniedHandler);/ 4、RememberMe（记住我）@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; //配置记住密码 http.rememberMe() .rememberMeParameter(\"remember-me\") // 修改请求参数名。 默认是remember-me .tokenValiditySeconds(14*24*60*60) // 设置记住我有效时间。单位是秒。默认是14天 .rememberMeCookieName(\"remember-me\") // 修改remember me的cookie名称。默认是remember-me .tokenRepository(persistentTokenRepository) // 配置用户登录标记的持久化工具对象。 .userDetailsService(userSecurity); // 配置自定义的UserDetailsService接口实现类对象 &#125; @Bean public PersistentTokenRepository persistentTokenRepository(DataSource dataSource)&#123; JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); //jdbcTokenRepository.setCreateTableOnStartup(true); return jdbcTokenRepository; &#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"三、Eureka学习","date":"2022-10-23T10:35:00.487Z","updated":"2022-10-23T10:21:42.450Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"一、基本架构Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址提供者：启动后向Eureka注册自己信息（地址，提供什么服务）消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发 送给消费者，并且定期更新。心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 二、Eureka Server2.1、新建maven 工程eureka-server&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>edu.xja&lt;/groupId> &lt;artifactId>eureka-server&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>2.3.12.RELEASE&lt;/version> &lt;/parent> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;project.reporting.outputEncoding>UTF-8&lt;/project.reporting.outputEncoding> &lt;java.version>1.8&lt;/java.version> &lt;spring-cloud.version>Hoxton.SR12&lt;/spring-cloud.version> &lt;/properties> &lt;dependencies> &lt;!--springcloud--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-server&lt;/artifactId> &lt;/dependency> &lt;/dependencies> &lt;dependencyManagement> &lt;dependencies> &lt;!--springcloud--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>$&#123;spring-cloud.version&#125;&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;/dependencies> &lt;/dependencyManagement> &lt;build> &lt;plugins> &lt;!--springboot的maven插件--> &lt;plugin> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId> &lt;/plugin> &lt;/plugins> &lt;/build> &lt;/project> application.yml 对注册中心进行配置 server: port: 8761 # 指定该Eureka实例的端口 spring: application: name: euremka-server # eureka server 配置 eureka: client: #是否将自己注册到注册中心 registerWithEureka: false #是否从EurekaServer 获取注册信息 fetchRegistry: false #设置与eureka交互的地址 serviceUrl: defaultZone: http://localhost:8761/eureka/ edu.xja 包下编写启动类EurekaApplication，加入注解@EnableEurekaServer /** * 使用Eureka做服务发现. * @author Thomas */ @SpringBootApplication @EnableEurekaServer public class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125; &#125; 2.2、启动eureka server测试访问http://localhost:8761/（不小心把歌词也截下来了，哈哈哈，工作也要来点音乐不是吗） 三、Eureka Client3.1、创建新模块microservice-provider-usermicroservice-provider-user/pom.xml 文件中加入eureka-client 依赖 &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId> &lt;/dependency> 3.2、注册配置中心信息application.yml中添加 spring: application: name: user-provider eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 3.3、启动microservice-provider-user访问注册中心：http://localhost:8761/","categories":[],"tags":[]},{"title":"","slug":"七、Feign日志","date":"2022-10-23T10:35:00.477Z","updated":"2022-10-23T10:22:19.657Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"我们可以每个Feign客户端配置各自的Logger.Level对象，告诉Feign记录哪些日志。Logger.Level的值有以下选择：Ø NONE： 不记录任何日志（默认值）Ø BASIC： 仅记录请求方法、URL、响应状态代码以及执行时间。Ø HEADERS: 记录basic级别的基础上，记录请求和响应的header。Ø FULL： 记录请求和响应的header、body和元数据。 一、使用编码方式设置日志级别复制工程microservice-consumer-movie-feign到microservice-consumer-movie-feign-log编写Feign配置类 @Configuration public class FeignLogConfiguration &#123; @Bean Logger.Level feignLoggerLevel() &#123; return Logger.Level.BASIC; &#125; &#125; 注意把config放到扫描范围的外面疑问：如果放到扫描范围内，加@Configuration和不加的区别修改Feign接口，指定配置类 @FeignClient(name = “user-provider\", configuration = FeignLogConfiguration.class) public interface UserFeignClient &#123; @RequestMapping(value = \"/&#123;id&#125;\", method = RequestMethod.GET) public User findById(@PathVariable(\"id\") Long id); &#125; 修改application.yml，指定Feign接口的日志级别为DEBUG logging: level: edu.xja.feign.UserClientFeign: DEBUG # 将Feign接口的日志级别设置成DEBUG，因为Feign的 #Logger.Level只对DEBUG作出响应。 二、使用属性配置日志级别feign: client: config: user-provider: loggerLevel: headers logging: level: edu.xja.feign.UserClientFeign: DEBUG # 将Feign接口的日志级别设置成DEBUG，因为Feign的Logger.Level只对DEBUG作出响应。","categories":[],"tags":[]},{"title":"","slug":"内网穿透技术","date":"2022-10-23T10:35:00.473Z","updated":"2022-10-23T10:19:04.798Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"某些情况下，我们希望放开本地的http端口供外网访问，可以使用内网穿透工具netapp。比如，开发支付程序回调接口，只允许配置外网ip或者域名，如果我们不购买云服务器及配置域名的情况下，可以使用内网穿透工具netapp来实现。 1、详细见网址：https://natapp.cn/ 2、注册账号3、购买隧道（也可使用free的隧道）单击上图购买隧道 4、下载客户端下载后如下：解压，解压后的目录如下：进入解压后的目录，新建config.ini文件，如下：修改config.ini里的内容，如下： | #将本文件放置于natapp同级目录 程序将读取 [default] 段#在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置#命令行参数 -config= 可以指定任意config.ini文件[default]authtoken= #对应一条隧道的authtokenclienttoken= #对应客户端的clienttoken,将会忽略authtoken,若无请留空,log=none #log 日志文件,可指定本地文件, none=不做记录,stdout=直接屏幕输出 ,默认为noneloglevel=ERROR #日志等级 DEBUG, INFO, WARNING, ERROR 默认为 DEBUGhttp_proxy= #代理设置 如 http://10.123.10.10:3128 非代理上网用户请务必留空 || — | 在网站上找到authtoken，见下图，替换上图中选中部分保存即可 5、启动客户端双击natapp.exe 即可启动，免费的隧道会在客户端产生随机的域名。","categories":[],"tags":[]},{"title":"","slug":"六、Feign学习","date":"2022-10-23T10:35:00.469Z","updated":"2022-10-23T10:22:09.008Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"一、添加依赖&lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-openfeign&lt;/artifactId> &lt;/dependency> 二、创建一个Feign接口创建一个Feign接口并添加@FeignClient注解 @FeignClient(name=\"user-provider\") public interface UserFeignClient &#123; @GetMapping(\"/user/&#123;id&#125;\") User getById(@PathVariable(\"id\") Integer id); &#125; @FeignClient注解中的name属性是一个任意的客户端名称，用于创建Ribbon负载均衡器。 三、修改controller修改MovieController，让其调用Feign @RestController @Slf4j public class MovieController &#123; @Resource private UserFeignClient userFeignClient; @GetMapping(\"/user/&#123;id&#125;\") public User findById(@PathVariable Integer id) &#123; return userFeignClient.getById(id); &#125; &#125; 四、修改启动类添加@EnableFeignClients注解 @SpringBootApplication @EnableFeignClients public class MovieApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MovieApplication.class, args); &#125; &#125; 如果出现问题，配置下面选项 spring: main: allow-bean-definition-overriding: true 启动测试 先启动注册中心Eureka-server 然后启动两个提供者 microservice-provider-user java -jar microservice-provider-user-1.0-SNAPSHOT.jar java -Dserver.port=9999 -jar microservice-provider-user-1.0-SNAPSHOT.jar 注意：服务提供者使用单机注册中心，不是集群 然后启动服务消费者 访问controller 进行测试（microservice-consumer-moive-feign）","categories":[],"tags":[]},{"title":"","slug":"服务雪崩、限流、熔断、降级","date":"2022-10-23T10:35:00.465Z","updated":"2022-10-23T10:18:53.563Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1、雪崩：当服务A调用服务B，服务B调用服务C，然后大量请求突然请求服务A，传给服务B，最后传给服务C，由于c的性能不好，导致大量的服务积压，从而使服务B、A请求积压，从而导致服务不可用。 解决：服务降级或者熔断 2、限流：在高并发请求下，为了保护系统，对访问服务的请求的数量进行限制，从而不被大量请求压垮。 3、熔断：指当服务A调用服务B时，由于服务B不可用，服务A就不再去调用服B，直接返回一个结果，直到服务B恢复 4、降级：系统压力过大时，就会关闭或者限制某一个服务，从而减轻服务器压力。","categories":[],"tags":[]},{"title":"","slug":"定时任务","date":"2022-10-23T10:35:00.461Z","updated":"2022-10-23T10:18:00.217Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"定时任务是企业级开发中最常见的功能之一，如定时统计订单数、数据库备份、定时发送短信和邮件、定时统计博客访客等，简单的定时任务可以直接通过Spring中的@Scheduled注解来实现，复杂的定时任务则可以通过集成Quartz来实现。 1 、@Scheduled@Scheduled是由Spring提供的定时任务注解，使用方便，配置简单，可以解决工作中大部分的定时任务需求，使用方式如下。 2 、开启定时任务在启动类上添加@EnableScheduling注解开启定时任务，代码如下： @SpringBootApplication @EnableScheduling @MapperScan(\"edu.xja.dao\") public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class,args); &#125; &#125; 3、 配置定时任务@Component public class MySchedule &#123; @Scheduled(fixedDelay = 1000) public void fixedDelay()&#123; System.out.println(\"fixed delay:\"+new Date()); &#125; @Scheduled(fixedRate = 2000) public void fixedRate()&#123; System.out.println(\"fixed rate:\"+new Date()); &#125; @Scheduled(initialDelay = 1000,fixedRate = 2000) public void initialDelay()&#123; System.out.println(\"initial delay:\"+new Date()); &#125; @Scheduled(cron=\"0 */1 * * * ?\") public void cron()&#123; System.out.println(\"cron: \"+new Date()); &#125; &#125; 代码说明：通过@Schedule 注解来标注一个定时任务，其中fixedDelay=1000 表示在当前任务执行结束1秒后开启另一个任务，fixRate=2000 表示在当前任务开始执行2秒后开启另一个定时任务，initialDelay =1000 表示首次执行的延迟时间。在@Schedule 注解中可以使用cron表达式，cron=”0 1 * * * ?”表示该定时任务每分钟执行一次。 Cron表达式| cron从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份（1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点执行任务（2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业（3）0 15 10 ? * 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作（4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点（5）0,2,4 0/30 9-17 * * ? 朝九晚五工作时间内每半小时（6）0 0 12 ? * WED 表示每个星期三中午12点（7）0 0 12 * * ? 每天中午12点触发（8）0 15 10 ? * * 每天上午10:15触发（9）0 15 10 * * ? 每天上午10:15触发（10）0 15 10 * * ? * 每天上午10:15触发（11）0 15 10 * * ? 2005 2005年的每天上午10:15触发（12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发（13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发（14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发（15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发（16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发（17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发（18）0 15 10 15 * ? 每月15日上午10:15触发（19）0 15 10 L * ? 每月最后一日的上午10:15触发（20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发（21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发（22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 || — | Cron表达式简介： | cron表达式用于配置cronTrigger的实例。cron表达式实际上是由七个子表达式组成。这些表达式之间用空格分隔。1.Seconds （秒）2.Minutes（分）3.Hours（小时）4.Day-of-Month （天）5.Month（月）6.Day-of-Week （周）7.Year（年）例：”0 0 12 ? * WED” 意思是：每个星期三的中午12点执行。个别子表达式可以包含范围或者列表。例如：上面例子中的WED可以换成”MON-FRI”，”MON,WED,FRI”，甚至”MON-WED,SAT”。子表达式范围：1.Seconds (059)2.Minutes (059)3.Hours (023)4.Day-of-Month (131,但是要注意有些月份没有31天)5.Month (011，或者”JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV,DEC”)6.Day-of-Week (17,1=SUN 或者”SUN, MON, TUE, WED, THU, FRI, SAT”)7.Year (1970~2099)Cron表达式的格式：秒 分 时 日 月 周 年(可选)。字段名 允许的值 允许的特殊字符秒 0-59 , - * /分 0-59 , - * /小时 0-23 , - * /日 1-31 , - * ? / L W C月 1-12 or JAN-DEC , - * /周几 1-7 or SUN-SAT , - * ? / L C #年(可选字段) empty 1970-2099 , - * /字符含义： ：代表所有可能的值。因此，“*”在Month中表示每个月，在Day-of-Month中表示每天，在Hours表示每小时 ：表示指定范围。, ：表示列出枚举值。例如：在Minutes子表达式中，“5,20”表示在5分钟和20分钟触发。/ ：被用于指定增量。例如：在Minutes子表达式中，“0/15”表示从0分钟开始，每15分钟执行一次。”3/20”表示从第三分钟开始，每20分钟执行一次。和”3,23,43”（表示第3，23，43分钟触发）的含义一样。? ：用在Day-of-Month和Day-of-Week中，指“没有具体的值”。当两个子表达式其中一个被指定了值以后，为了避免冲突，需要将另外一个的值设为“?”。例如：想在每月20日触发调度，不管20号是星期几，只能用如下写法：0 0 0 20 * ?，其中最后以为只能用“?”，而不能用“*”。L ：用在day-of-month和day-of-week字串中。它是单词“last”的缩写。它在两个子表达式中的含义是不同的。在day-of-month中，“L”表示一个月的最后一天，一月31号，3月30号。在day-of-week中，“L”表示一个星期的最后一天，也就是“7”或者“SAT”如果“L”前有具体内容，它就有其他的含义了。例如：“6L”表示这个月的倒数第六天。“FRIL”表示这个月的最后一个星期五。注意：在使用“L”参数时，不要指定列表或者范围，这样会出现问题。W ：“Weekday”的缩写。只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。例如：在day-of-month字段用“15W”指“最接近这个月第15天的工作日”，即如果这个月第15天是周六，那么触发器将会在这个月第14天即周五触发；如果这个月第15天是周日，那么触发器将会在这个月第 16天即周一触发；如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。“W”字符仅能在 day-of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日，即最后一个星期五。：只能用在day-of-week字段。用来指定这个月的第几个周几。例：在day-of-week字段用”6#3” or “FRI#3”指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发。 || — |","categories":[],"tags":[]},{"title":"","slug":"八_、使用Feign构造多参数请求","date":"2022-10-23T10:35:00.457Z","updated":"2022-10-23T10:22:28.611Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"假设url中包含多个参数，比如http://user-provider/user/get?ID=1&amp;username=zhangsan用户服务提供端。UserDao加入方法： /** * 根据用户名和年龄获取用户 * @param username * @param age * @return */ User getByUsernameAndAge(@Param(\"username\") String username,@Param(\"age\") Integer age); User.xml 加入 &lt;select id=\"getByUsernameAndAge\" resultType=\"User\"> select id,username, age, name,balance from t_user where username = #&#123;username&#125; and age=#&#123;age&#125; &lt;/select> UserService和UserServiceImpl 分别加入方法 UserController 中加入方法 @GetMapping(\"/getByUsernameAndAge\") public User getByUsernameAndAge(User user) &#123; return userService.getByUsernameAndAge(user.getUsername(),user.getAge()); &#125; 修改microservice-consumer-movie-feign工程中的UserClientFeign类 注：错误写法： @GetMapping(\"/user/getByUsernameAndAge\") User getByUsernameAndAge(@RequestBody User user); MovieController中加入方法用于测试 @GetMapping(\"/getByUsernameAndAge\") public User getByUsernameAndAge()&#123; User user=new User(); user.setUsername(\"zhaoliu\"); user.setAge(20); return userClientFeign.getByUsernameAndAge(user); &#125; 启动相关服务测试 | 启动注册中心eureka-server启动服务提供者microservice-provider-user启动服务消费者microservice-consumer-movie-feign浏览器器访问：进行测试 || — | 正确写法：方法一： @GetMapping(\"/user/getByUsernameAndAge\") User getByUsernameAndAge1(@RequestParam(\"username\") String username,@RequestParam(\"age\") int age); @GetMapping(\"/getByUsernameAndAge1\") public User getByUsernameAndAge1()&#123; return userClientFeign.getByUsernameAndAge1(\"zhaoliu\",20); &#125; 方法二：多参数的URL也可以使用Map构建。当目标url参数非常多时，可以使用这种方式简化Feign接口的编写。 @GetMapping(\"/user/getByUsernameAndAge\") User getByUsernameAndAge2(@RequestParam Map&lt;String,Object> userMap); @GetMapping(\"/getByUsernameAndAge2\") public User getByUsernameAndAge2()&#123; Map&lt;String,Object> map=new HashMap&lt;>(); map.put(\"username\",\"zhaoliu\"); map.put(\"age\",20); return userClientFeign.getByUsernameAndAge2(map); &#125; POST请求包含多个参数@PostMapping(\"/user/add\") int addUser(@RequestBody User user); Controller里加入 @PostMapping(\"/add\") public int getByUsernameAndAge2(@RequestBody User user)&#123; return userClientFeign.addUser(user); &#125;","categories":[],"tags":[]},{"title":"","slug":"阿里支付-AliPay（手机页面）","date":"2022-10-23T10:35:00.452Z","updated":"2022-10-23T10:19:31.249Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"若使用阿里支付，前提需要支付宝注册沙箱账号。 下载手机网站支付Demo进入文档中心https://openhome.alipay.com/docCenter/docCenter.htm单击下图链接下载后如下：由于本项目使用eclips和jsp编写的，若加载到idea需要进行相应配置： 解压 10.1.3 删除无用文件和文件夹只保留src、WebContent和readme.txt文件夹，其他删除，删除后如下 10.1.4 使用idea打开并把工程改成web工程及部署到tomcat上对web.xml的文件路径也需要配置:配置tomcat： 10.1.5修改参数及文件修改AlipayConfig如果文件打开后出现以下错误旧版idea：新版idea： 项目配置完成后可运行,使用手机端沙箱版支付宝进行支付操作","categories":[],"tags":[]},{"title":"","slug":"阿里支付-AliPay（电脑页面）2","date":"2022-10-23T10:35:00.448Z","updated":"2022-10-23T10:19:15.110Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1、添加依赖2、将对应的属性配置进yml文件中alipay: app_id: 2021000121655659 merchant_private_key: MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQCQYu5FkXjl6uDzjw7/ZRAiou0gV5AZuUSHSDii6u+zR+GqHu6QCh9HbFBMWeuW8rCzl8eUAck3HfdPtcrmvZqqdsk4h5G03zwQJCTL6PB5ZJzFTueffPX2A+lMXek4BXv3rnTTUEAQYqga5Act9ZX5+964kURWOAsmd8/6Za3e8f+qf4X6+dJac6Gf9LcFpIhRVyP9ODkGRcUyRVC0W5VOIP8NSQSZSk0pe+rFh+/IOrBIdwtgQuLC2wayLqg+YzzIIxmh8fegsB+i36O/DinLbbPaDVBpyQkpVIK1tR4Amn2AdFljVM9ytgVAL9bc/EWbJ9mHGQPAczy4jFRckVZZAgMBAAECggEAcKDbYOUTO7Y2d4cWmd6J8ZrKAjqLq6U7cZPCqkM9a8ocnAm46h8bOymgkY5rGbqCX/V7t1aVUStM6Z7TgZ5RcbtrR29pF4AzaBvpoC46t1bme3sLbvuZGaj/aZSwAgU1KIWrl9K3xpBOtXs+pnk13mS83ZhjiCX7fKxlTdvW/1rvtRnfpS6n9TESxaeYhalkSCb0tz2DSL++zagjvxzmH2WcGijQygVsIoBTYCxh4ahTlViI+mQmJ8yXVwVtkYtuV3T47456JngD5n6IUKf52eNVs9STgc3+ULnOE8B/QK1pDxJPYWOpRGoEZUvfEPQHK0rb1VNqJzyvFD8kd1VWKQKBgQDug5xGjPTnPZhU1uS+n0PNu7s3gQ8FAC6B3Vi2xNQeYcqRidy5mK0kSIyCNCKRYxnKLmY+ZvECXJnwmrfQv6do5Zx22YMdHzjrcqKTc5eKtYj3OWcMSpnw+UzaOGuEjUGHbrhzJw2yiKH6ABM0+FnDmT/hNzqTCwunBNu5Xqo/FwKBgQCa+L/ewdhsx/Eu92GQUKe6L6M15VcM6bPVcoO8CpZPnKCkstc2C9mXSYhAfpGJJmRTSjA3iBd5kCJiQndE/Kup4u4STNkBuII4Av9YeAKAgnaFXhYwnsVVL9vq4fzwBs8P/IE6S4abPIcI+vw2EJD14ytOko3j4XzTV1aLb4v8DwKBgH60fc1gzi0VpJnVOtklBEEDrLYUomT2rr4gVyNotoKZUqI0CYSy3a+7tqDoj0CK08V7FqepyfiGNuUBXArR9V4dNBxS+nr6/iLd2A3axzNRsrway2pVKyg/V5tJg5x76cbHg8bwhS9FtD550bo/AHiPLcc3rq80m/ES/KKh7nDrAoGAD7EYXInsTDeCqGrMKjzAfw3LzO1H/zq6xuYtiKDZz33glky1lfdlNPhxH3axbd3BUt20PCs/lUOO97wbL5UWHMGpsZiucIoqRVmoWWDtf+216pM4U/v/pzyNXB896WAHH2tF+o0jOBzM34/qcd8DjqJOBEq6q1Rtu0igrsXAuukCgYAca1266FIYRAhduh9/AeAioMz/BkeNq9nXETe4AG0BVtJA7y7mP7Mx6UUNA93gAblxjbLa/OaUngIRU/CMduEDLfxVqCODzPRl/tvd70IJS1WFCdg+CSMoQy4SX181oJdIfqYB7BzJZRfM+58fuyr584oNsUcMsXltXHNMAgJQRQ== alipay_public_key: MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAih0FQQKQXeJ4PjNZGAj9atlI6yRbh4h1jR9hxJhSKz3zDRhsQGOGntN51lntVwnYzi8V5cmkubFJxfXKwECDfi6ut5ZlRFMFhrhpeA9G1totJ+LbmX6+DyA1NV6VWJHNpAzCjV5ZN/nSOmxMLFIHSO0riery2NOgqovcL8+NiJ2j/H2/XsRmH3ralqZFcKV3j0mWlr0lA1PgalpKX4mk4aWmf9u1a9RluKvn98cBaqmshzqdZGWpVQm7Db5l+QdAy4KazMxdxoq+0sPu7R/qxNOFIqVl33giqL0WXNbd5Yt6LAAlzufbtK+f+utyVnMt7LIR2uF8d196e8Vu4xRQdwIDAQAB notify_url: http://xuyuantree.natapp1.cc/alipay/notify/myNotify return_url: http://xuyuantree.natapp1.cc/alipay/notify/myNotify sign_type: RSA2 charset: UTF-8 gatewayUrl: https://openapi.alipaydev.com/gateway.do log_path: C:\\\\ format: json 3、创建config配置类，返回一个AlipayClient类：@Component @ConfigurationProperties(prefix = \"alipay\") @Data public class AlipayConfig &#123; private String appId; private String merchantPrivateKey; private String alipayPublicKey; private String notifyUrl; private String returnUrl; private String signType; private String charset; private String gatewayUrl; private String logPath; private String format; @Bean public AlipayClient AlipayClient()&#123; return new DefaultAlipayClient(gatewayUrl, appId, merchantPrivateKey, format, charset, alipayPublicKey, signType); &#125; &#125; 4、编写支付请求控制层@RestController @RequestMapping(\"/pay\") public class AlipayController &#123; @Resource private AlipayClient alipayClient; @Resource private AlipayConfig alipayConfig; @GetMapping(\"/page\") public String payPage() throws AlipayApiException &#123; //2、创建请求 AlipayTradePagePayRequest request=new AlipayTradePagePayRequest(); //回调地址 request.setReturnUrl(alipayConfig.getReturnUrl()); request.setNotifyUrl(alipayConfig.getNotifyUrl()); //3、创建请求数据模型 AlipayTradePagePayModel model = new AlipayTradePagePayModel(); //4 model中写入订单数据 model.setOutTradeNo(UUID.randomUUID().toString()); model.setTotalAmount(\"300\"); model.setSubject(\"iPhone 13 Pro\"); model.setBody(\"商品\"); model.setProductCode(\"FAST_INSTANT_TRADE_PAY\"); //5 把model放到request里面 request.setBizModel(model); //6 获取请求表单 String form = alipayClient.pageExecute(request).getBody(); //返回表单 return form; &#125; &#125; 5、编写回调控制层@RestController @RequestMapping(\"/alipay/notify\") public class NotifyController &#123; @Resource private AlipayConfig alipayConfig; @RequestMapping(\"/myNotify\") public String notify(HttpServletRequest request) throws UnsupportedEncodingException, AlipayApiException &#123; //获取支付宝POST过来反馈信息 Map&lt;String,String> params = new HashMap&lt;String,String>(); Map&lt;String,String[]> requestParams = request.getParameterMap(); for (Iterator&lt;String> iter = requestParams.keySet().iterator(); iter.hasNext();) &#123; String name = (String) iter.next(); String[] values = (String[]) requestParams.get(name); String valueStr = \"\"; for (int i = 0; i &lt; values.length; i++) &#123; valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + \",\"; &#125; //乱码解决，这段代码在出现乱码时使用 valueStr = new String(valueStr.getBytes(\"ISO-8859-1\"), \"utf-8\"); params.put(name, valueStr); &#125; boolean signVerified = AlipaySignature.rsaCheckV1(params, alipayConfig.getAlipayPublicKey(), alipayConfig.getCharset(),alipayConfig.getSignType()); //调用SDK验证签名 if(signVerified)&#123; String outTradeNos = requestParams.get(\"out_trade_no\")[0]; String tradeNo = requestParams.get(\"trade_no\")[0]; String tradeStatuses = requestParams.get(\"trade_status\")[0]; if(tradeStatuses.equals(\"TRADE_SUCCESS\"))&#123; //TODO 更新成数据库表的状态，更新成已支付 //TODO 出货 return \"success\"; &#125;else &#123; return \"fail\"; &#125; &#125; return \"invalid signature!\"; &#125; &#125; 应该将前两个控制层中业务写入service层，请自行修改。","categories":[],"tags":[]},{"title":"","slug":"阿里支付-AliPay（电脑页面）1","date":"2022-10-23T10:35:00.444Z","updated":"2022-10-23T10:19:23.214Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"第一种方式：1、利用Springboot集成：引入依赖： &lt;!--alipay网页支付--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;&#x2F;groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;&#x2F;artifactId&gt; &lt;version&gt;4.33.26.ALL&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; 2、拷贝下载好的demo（_若不知demo如何下载，请见阿里支付-AliPay（手机页面）_）中**AlipayConfig **public class AlipayConfig &#123; //↓↓↓↓↓↓↓↓↓↓请在这里配置您的基本信息↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ // 应用ID,您的APPID，收款账号既是您的APPID对应支付宝账号 public static String app_id = \"**********\"; // 商户私钥，您的PKCS8格式RSA2私钥 public static String merchant_private_key = \"*******\"; // 支付宝公钥,查看地址：https://openhome.alipay.com/platform/keyManage.htm 对应APPID下的支付宝公钥。 public static String alipay_public_key = \"*******\"; // 服务器异步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 public static String notify_url = \"http://xuyuantree.natapp1.cc/alipay/notify/myNotify\"; // 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问 public static String return_url = \"http://xuyuantree.natapp1.cc/alipay/notify/myNotify\"; // 签名方式 public static String sign_type = \"RSA2\"; // 字符编码格式 public static String charset = \"utf-8\"; // 支付宝网关 public static String gatewayUrl = \"https://openapi.alipaydev.com/gateway.do\"; // 支付宝网关 public static String log_path = \"C:\\\\\"; //↑↑↑↑↑↑↑↑↑↑请在这里配置您的基本信息↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ /** * 写日志，方便测试（看网站需求，也可以改成把记录存入数据库） * @param sWord 要写入日志里的文本内容 */ public static void logResult(String sWord) &#123; FileWriter writer = null; try &#123; writer = new FileWriter(log_path + \"alipay_log_\" + System.currentTimeMillis()+\".txt\"); writer.write(sWord); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 3、新建请求支付宝支付的controller@RestController @RequestMapping(\"/pay\") public class AlipayController &#123; @RequestMapping(\"/page\") public String pagePay() throws AlipayApiException &#123; //获得初始化的AlipayClient AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.gatewayUrl, AlipayConfig.app_id, AlipayConfig.merchant_private_key, \"json\", AlipayConfig.charset, AlipayConfig.alipay_public_key, AlipayConfig.sign_type); //设置请求参数 AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest(); alipayRequest.setReturnUrl(AlipayConfig.return_url); alipayRequest.setNotifyUrl(AlipayConfig.notify_url); //商户订单号，商户网站订单系统中唯一订单号，必填 String out_trade_no = \"2022083001001241-3\"; //付款金额，必填 String total_amount = \"100\"; //订单名称，必填 String subject =\"商品\"; //商品描述，可空 String body = \"张文立充值卡\"; alipayRequest.setBizContent(\"&#123;\\\"out_trade_no\\\":\\\"\"+ out_trade_no +\"\\\",\" + \"\\\"total_amount\\\":\\\"\"+ total_amount +\"\\\",\" + \"\\\"subject\\\":\\\"\"+ subject +\"\\\",\" + \"\\\"body\\\":\\\"\"+ body +\"\\\",\" + \"\\\"product_code\\\":\\\"FAST_INSTANT_TRADE_PAY\\\"&#125;\"); //若想给BizContent增加其他可选请求参数，以增加自定义超时时间参数timeout_express来举例说明 //alipayRequest.setBizContent(\"&#123;\\\"out_trade_no\\\":\\\"\"+ out_trade_no +\"\\\",\" // + \"\\\"total_amount\\\":\\\"\"+ total_amount +\"\\\",\" // + \"\\\"subject\\\":\\\"\"+ subject +\"\\\",\" // + \"\\\"body\\\":\\\"\"+ body +\"\\\",\" // + \"\\\"timeout_express\\\":\\\"10m\\\",\" // + \"\\\"product_code\\\":\\\"FAST_INSTANT_TRADE_PAY\\\"&#125;\"); //请求参数可查阅【电脑网站支付的API文档-alipay.trade.page.pay-请求参数】章节 //请求 String result = alipayClient.pageExecute(alipayRequest).getBody(); //输出 return result; &#125; &#125; 4、新建回调controller@RestController @RequestMapping(\"/alipay/notify\") public class NotifyController &#123; @RequestMapping(\"/myNotify\") public String notify(HttpServletRequest request) throws UnsupportedEncodingException, AlipayApiException &#123; /* * * 功能：支付宝服务器异步通知页面 * 日期：2017-03-30 * 说明： * 以下代码只是为了方便商户测试而提供的样例代码，商户可以根据自己网站的需要，按照技术文档编写,并非一定要使用该代码。 * 该代码仅供学习和研究支付宝接口使用，只是提供一个参考。 *************************页面功能说明************************* * 创建该页面文件时，请留心该页面文件中无任何HTML代码及空格。 * 该页面不能在本机电脑测试，请到服务器上做测试。请确保外部可以访问该页面。 * 如果没有收到该页面返回的 success * 建议该页面只做支付成功的业务逻辑处理，退款的处理请以调用退款查询接口的结果为准。 */ //获取支付宝POST过来反馈信息 Map&lt;String,String> params = new HashMap&lt;String,String>(); Map&lt;String,String[]> requestParams = request.getParameterMap(); for (Iterator&lt;String> iter = requestParams.keySet().iterator(); iter.hasNext();) &#123; String name = (String) iter.next(); String[] values = (String[]) requestParams.get(name); String valueStr = \"\"; for (int i = 0; i &lt; values.length; i++) &#123; valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + \",\"; &#125; //乱码解决，这段代码在出现乱码时使用 valueStr = new String(valueStr.getBytes(\"ISO-8859-1\"), \"utf-8\"); params.put(name, valueStr); &#125; boolean signVerified = AlipaySignature.rsaCheckV1(params, AlipayConfig.alipay_public_key, AlipayConfig.charset, AlipayConfig.sign_type); //调用SDK验证签名 //——请在这里编写您的程序（以下代码仅作参考）—— /* 实际验证过程建议商户务必添加以下校验： 1、需要验证该通知数据中的out_trade_no是否为商户系统中创建的订单号， 2、判断total_amount是否确实为该订单的实际金额（即商户订单创建时的金额）， 3、校验通知中的seller_id（或者seller_email) 是否为out_trade_no这笔单据的对应的操作方（有的时候，一个商户可能有多个seller_id/seller_email） 4、验证app_id是否为该商户本身。 */ if(signVerified) &#123;//验证成功 //商户订单号 String out_trade_no = new String(request.getParameter(\"out_trade_no\").getBytes(\"ISO-8859-1\"),\"UTF-8\"); //支付宝交易号 String trade_no = new String(request.getParameter(\"trade_no\").getBytes(\"ISO-8859-1\"),\"UTF-8\"); //交易状态 String trade_status = new String(request.getParameter(\"trade_status\").getBytes(\"ISO-8859-1\"),\"UTF-8\"); if(trade_status.equals(\"TRADE_FINISHED\"))&#123; //判断该笔订单是否在商户网站中已经做过处理 //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序 //如果有做过处理，不执行商户的业务程序 //注意： //退款日期超过可退款期限后（如三个月可退款），支付宝系统发送该交易状态通知 &#125;else if (trade_status.equals(\"TRADE_SUCCESS\"))&#123; //判断该笔订单是否在商户网站中已经做过处理 //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序 //如果有做过处理，不执行商户的业务程序 //注意： //付款完成后，支付宝系统发送该交易状态通知 &#125; return \"success\"; &#125;else &#123;//验证失败 return \"fail\"; //调试用，写文本函数记录程序运行情况是否正常 //String sWord = AlipaySignature.getSignCheckContentV1(params); //AlipayConfig.logResult(sWord); &#125; //——请在这里编写您的程序（以上代码仅作参考）—— &#125; &#125; 即可运行测试！","categories":[],"tags":[]},{"title":"","slug":"阿里云-对象存储OSS","date":"2022-10-23T10:35:00.440Z","updated":"2022-10-23T10:19:42.020Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"阿里云对象存储服务（Object Storage Service，简称 OSS）为您提供基于网络的数据存取服务。使用OSS，您可以通过网络随时存储和调用包括文本、图片、音频和视频等在内的各种数据文件。 1、Spring-boot 集成 OSS1-1、添加依赖SDK&lt;dependency> &lt;groupId>com.aliyun.oss&lt;/groupId> &lt;artifactId>aliyun-sdk-oss&lt;/artifactId> &lt;version>3.10.2&lt;/version> &lt;/dependency> 1-2、在yml中配置信息oss: config: endpoint: https://oss-cn-beijing.aliyuncs.com accessKeyId: ****** accessKeySecret: ******* bucketName: ********* spring: servlet: multipart: max-file-size: 5000000 server: port: 9999 1-3、新建功能类OssUtil：@Component public class OssUtils &#123; @Value(\"$&#123;oss.config.endpoint&#125;\") private String endpoint; @Value(\"$&#123;oss.config.accessKeyId&#125;\") private String accessKeyId; @Value(\"$&#123;oss.config.accessKeySecret&#125;\") private String accessKeySecret; public OSS createOssClient()&#123; // 创建OSSClient实例。 return new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); &#125; &#125; 1-4、添加服务类接口：public interface OssService &#123; String uploadFileAvatar(InputStream inputStream, String module, String originalFilename); &#125; 1-5、添加实现类：@Service @Slf4j public class OssServiceImpl implements OssService &#123; @Resource private OssUtils ossUtils; @Value(\"$&#123;oss.config.bucketName&#125;\") private String bucketName; @Value(\"$&#123;oss.config.endpoint&#125;\") private String endpoint; @Override public String uploadFileAvatar(InputStream inputStream, String module, String originalFilename) &#123; //创建OSS实例 OSS ossClient = ossUtils.createOssClient(); SimpleDateFormat simpleDateFormat=new SimpleDateFormat(\"yyyy/MM/dd\"); String folder = simpleDateFormat.format(new Date()); String fileName = UUID.randomUUID().toString(); String fileExtension = originalFilename.substring(originalFilename.lastIndexOf(\".\")); // oss中的文件夹名 String objectName = module + \"/\" + folder + \"/\" + fileName + fileExtension; // 创建上传文件的元信息，可以通过文件元信息设置HTTP header(设置了才能通过返回的链接直接访问)。 //如果不设置，直接访问url会自行下载图片，看各位自己选择 ObjectMetadata objectMetadata = new ObjectMetadata(); objectMetadata.setContentType(\"image/png\"); PutObjectResult putObjectResult = ossClient.putObject(bucketName, objectName, inputStream, objectMetadata); String url=endpoint.replaceFirst(\"https://\",\"https://\"+bucketName +\".\")+\"/\"+objectName; log.info(url); // 关闭OSSClient。 ossClient.shutdown(); return url; &#125; &#125; 1-6、添加控制类：@RestController @RequestMapping(\"/oss\") public class OssController &#123; @Autowired private OssService ossService; //上传图片的方法 @PostMapping(\"/uploadAvator\") public HttpResult uploadOssFile(@RequestParam(\"file\") MultipartFile file, @RequestParam(\"module\") String module) &#123; //获取上传文件 MultipartFile InputStream inputStream = null; try &#123; inputStream = file.getInputStream(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String url = ossService.uploadFileAvatar(inputStream,module,file.getOriginalFilename()); return HttpResult.ok(url); &#125; &#125; 需要添加跨域请求，详细请见Vue知识库中Ajex请求。 1-7、前端Vue参考代码&lt;template&gt; &lt;div&gt; 上传头像：&lt;input type&#x3D;&quot;file&quot; ref&#x3D;&quot;file1&quot; name&#x3D;&quot;headPortrait&quot; &#x2F;&gt; 文件夹：&lt;input v-model&#x3D;&quot;module&quot; &#x2F;&gt; &lt;button @click&#x3D;&quot;uploadAvator&quot;&gt;上传&lt;&#x2F;button&gt; &lt;br&#x2F;&gt; &lt;img :src&#x3D;&quot;info&quot;&#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import axios from &quot;axios&quot;; export default &#123; data() &#123; return &#123; file: &quot;&quot;, module: &quot;avator&quot;, baseUrl: &quot;http:&#x2F;&#x2F;localhost:9999&#x2F;&quot;, info: &quot;&quot; &#125;; &#125;, methods: &#123; uploadAvator() &#123; &#x2F;&#x2F;设置请求url let url &#x3D; this.baseUrl + &quot;oss&#x2F;uploadAvator&quot;; &#x2F;&#x2F;获取文件 const file &#x3D; this.$refs.file1.files[0]; console.log(file); &#x2F;&#x2F;设置表单数据 const data &#x3D; new FormData(); data.append(&quot;file&quot;, file); data.append(&quot;module&quot;, this.module); &#x2F;&#x2F;发送请求 axios .post(url, data, &#123; headers: &#123; &quot;Content-Type&quot;: &quot;multipart&#x2F;form-data&quot;, &#125;, &#125;) .then((rep) &#x3D;&gt; &#123; &#x2F;&#x2F;接收正常响应 if (rep.status &#x3D;&#x3D; 200) &#123; this.info &#x3D; rep.data.data; alert(this.info); &#125; &#125;) .catch(function (error) &#123; &#x2F;&#x2F; 请求失败处理 console.log(error); &#125;); &#125;, &#125;, &#125;; &lt;&#x2F;script&gt; &lt;style scoped&gt; &lt;&#x2F;style&gt;","categories":[],"tags":[]},{"title":"","slug":"阿里云-大鱼短信","date":"2022-10-23T10:35:00.435Z","updated":"2022-10-23T10:19:49.383Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"添加依赖SDK：&lt;!--阿里云发送短信服务--> &lt;dependency> &lt;groupId>com.aliyun&lt;/groupId> &lt;artifactId>alibabacloud-dysmsapi20170525&lt;/artifactId> &lt;version>1.0.1&lt;/version> &lt;/dependency> 在application.yml中定义配置信息：alibaba: dy: accessKeyId: LTAI5******91G5N accessKeySecret: n5z33hrc*********1CT0Z region: cn-hangzhou signName: 勇往直前 templateCode: SMS_174024755 在util包中创建SendDyUtil工具类：@Slf4j @Component public class SendDyUtils &#123; @Value(\"$&#123;alibaba.dy.accessKeyId&#125;\") private String accessKeyId; @Value(\"$&#123;alibaba.dy.accessKeySecret&#125;\") private String accessKeySecret; @Value(\"$&#123;alibaba.dy.region&#125;\") private String region; @Value(\"$&#123;alibaba.dy.signName&#125;\") private String signName; @Value(\"$&#123;alibaba.dy.templateCode&#125;\") private String templateCode; public String sendMsg(String userPhone)&#123; String phoneCode=Integer.toString(100000 + new Random().nextInt(900000)); try &#123; StaticCredentialProvider provider = StaticCredentialProvider.create(Credential.builder() .accessKeyId(accessKeyId) .accessKeySecret(accessKeySecret) //.securityToken(\"&lt;your-token>\") // use STS token .build()); // Configure the Client AsyncClient client = AsyncClient.builder() .region(region) // Region ID .credentialsProvider(provider) .overrideConfiguration( ClientOverrideConfiguration.create() .setEndpointOverride(\"dysmsapi.aliyuncs.com\") //.setReadTimeout(Duration.ofSeconds(30)) ) .build(); // Parameter settings for API request SendSmsRequest sendSmsRequest = SendSmsRequest.builder() .phoneNumbers(userPhone) .signName(signName) .templateCode(templateCode) .templateParam(\"&#123;\\\"code\\\":\\\"\"+phoneCode+\"\\\"&#125;\") .build(); CompletableFuture&lt;SendSmsResponse> response = client.sendSms(sendSmsRequest); SendSmsResponse resp = response.get(); System.out.println(new Gson().toJson(resp)); //redisConfig.setting(\"randomCode\", this.randomCode); //result(); client.close(); return phoneCode; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); log.error(\"向手机号:\"+userPhone+\"发送错误原因\"+e.getMessage()); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); log.error(\"向手机号:\"+userPhone+\"发送错误原因\"+e.getMessage()); &#125; return null; &#125; &#125; 测试： //获取手机验证码 String phoneCode = sendDyUtils.sendMsg(userPhone);","categories":[],"tags":[]},{"title":"","slug":"volatile关键字作用及使用场景","date":"2022-10-23T10:35:00.431Z","updated":"2022-10-23T10:13:08.440Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1.volatile关键字的作用：保证了变量的可见性（visibility）。被volatile关键字修饰的变量，如果值发生了变更，其他线程立马可见，避免出现脏读的现象。如以下代码片段，isShutDown被置为true后，doWork方法仍有执行。如用volatile修饰isShutDown变量，可避免此问题。 1 public class VolatileTest3 &#123; 2 static class Work &#123; 3 boolean isShutDown = false;//没有加volatile，所以当isShutDown的值改变时，其他线程是不知道的，就会继续执行 4 5 void shutdown() &#123; 6 isShutDown = true; 7 System.out.println(\"shutdown!\"); 8 &#125; 9 10 void doWork() &#123; 11 while (!isShutDown) &#123; 12 System.out.println(\"doWork\"); 13 &#125; 14 &#125; 15 &#125; 16 17 public static void main(String[] args) &#123; 18 Work work = new Work(); 19 20 new Thread(work::doWork).start(); 21 new Thread(work::doWork).start(); 22 new Thread(work::doWork).start(); 23 new Thread(work::shutdown).start(); 24 new Thread(work::doWork).start(); 25 new Thread(work::doWork).start(); 26 new Thread(work::doWork).start(); 27 &#125; 28 &#125; 出现脏读时，运行结果如下： 为什么会出现脏读？Java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。变量的值何时从线程的工作内存写回主存，无法确定。 volatile 关键字（用来修饰被不同线程访问和修改的变量）（1）内存可见性：某线程对 volatile 变量的修改，对其他线程都是可见的。即获取 volatile 变量的值都是最新的。Java 中存在一种原则——先行发生原则（happens-before）。其表示两个事件结果之间的关系：如果一个事件发生在另一个事件之间，其结果必须体现。volatile 的内存可见性就体现了该原则：对于一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 volatile static int a = 0; //线程 A 在其工作内存中写入变量 a 的新值 1 a = 1 ; //线程 B 在主内存中读取变量 a 的值输出 System.out.println(a); 需要注意的是 volatile 能保证内存的可见性，但不能保证变量的原子性。 某一线程从主内存获取到共享变量的值，当其修改完变量值重新写入主内存时，并没有去判断主内存的值是否发生改变，有可能会出现意料之外的结果。例如：当多个线程都对某一 volatile 变量（int a=0）进行 count++ 操作时，由于 count++ 操作并不是原子性操作，当线程 A 执行 count++ 后，A 工作内存其副本的值为 1，但线程执行时间到了，主内存的值仍为 0 ；线程 B又来执行 count++后并将值更新到主内存，主内存此时的值为 1；然后线程 A 继续执行将值更新到主内存为 1，它并不知道线程 B 对变量进行了修改，也就是没有判断主内存的值是否发生改变，故最终结果为 1，但理论上 count++ 两次，值应该为 2。 所以要使用 volatile 的内存可见性特性的话得满足两个条件： 能确保只有单一的线程对共享变量的只进行修改。 变量不需要和其他状态变量共同参与不变的约束条件。 （2）禁止指令重排：指令重排：JVM 在编译 Java 代码时或 CPU 在执行 JVM 字节码时，对现有指令顺序进行重新排序，优化程序的运行效率。（在不改变程序执行结果的前提下指令重排虽说可以优化程序的执行效率，但在多线程问题上会影响结果。那么有什么解决办法呢？答案是内存屏障。内存屏障是一种屏障指令，使 CPU 或编译器对屏障指令之前和之后发出的内存操作执行一个排序的约束。 四种类型：LoadLoad 屏障、StoreStore 屏障、LoadStore 屏障、StoreLoad 屏障。（Load 代表读取指令、Store 代表写入操作） 在 volatile 变量上的体现：（JVM 执行操作） 在每个 volatile 写入操作前插入 StoreStore 屏障； 在写操作后插入 StoreLoad 屏障； 在读操作前插入 LoadLoad 屏障； 在读操作后插入 LoadStore 屏障； volatile 禁止指令重排在单例模式上有所体现，之前文章有所介绍（链接）。上边介绍的操作只是针对 volatile 读和 volatile 写这种组合情况。还有其他的情况就不一一展开了。 总结：（1）内存可见性的保证是基于屏障指令的。（2）禁止指令重排在编译时 JVM 编译器遵循内存屏障的约束，运行时靠屏障指令组织重排。（3）synchronized 关键字可以保证变量原子性和可见性；volatile 不能保证原子性。","categories":[],"tags":[]},{"title":"","slug":"Spring-boot系统启动任务","date":"2022-10-23T10:35:00.423Z","updated":"2022-10-23T10:17:52.010Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"有一些特殊的任务需要在系统启动时执行，例如配置文件的加载、数据库初始化等操作。 如果不使用Spring Boot，可以使用Listener解决。 Spring Boot 对此提供了两种解决方案，CommandLineRunner和ApplicationRunner。 CommandLineRunner和ApplicationRunner基本一致，差别主要体现在参数上 1 、CommandLineRunnerSpring Boot 项目在启动时会遍历所有CommandLineRunner的实现类并调用其中的run方法，如果整个系统中有多个CommandLineRunner的实现类，那么可以使用@Order注解对这些实现类的调用顺序进行排序。 @Component @Order(1) @Slf4j public class MyCommandLineRunner1 implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; log.info(\"Runner1>>>\"+ Arrays.toString(args)); &#125; &#125; @Component @Order(2) @Slf4j public class MyCommandLineRunner2 implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; log.info(\"Runner2>>>\"+ Arrays.toString(args)); &#125; &#125; 代码说明：@Order(2)注解来描述CommandLineRunner的执行顺序，数字越小越先执行。Run 方法中是调用的核心逻辑，参数是系统启动时传入的参数，即入口类中main方法的参数。 2 、ApplicationRunnerApplicationRunner的用法和CommandLineRunner基本一致，区别只要体现在run方法的参数上。 @Component @Order(1) @Slf4j public class MyApplicationRunner1 implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; List&lt;String> nonOptionArgs=args.getNonOptionArgs(); System.out.println(\"runner1-主方法的参数args：\"+nonOptionArgs); //getOptionNames()获取主函数参数中的键值对的所有键集合 Set&lt;String> optionNames=args.getOptionNames(); for(String optionName:optionNames)&#123; //getOptionValues(optionName)通过键获取值 System.out.println(\"runner1,key:\"+optionName+\";value=\"+args.getOptionValues(optionName)); &#125; &#125; &#125; @Component @Order(2) @Slf4j public class MyApplicationRunner2 implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; List&lt;String> nonOptionArgs=args.getNonOptionArgs(); System.out.println(\"runner2-主方法的参数args：\"+nonOptionArgs); Set&lt;String> optionNames=args.getOptionNames(); for(String optionName:optionNames)&#123; System.out.println(\"runner2,key:\"+optionNames+\";value=\"+args.getOptionValues(optionName)); &#125; &#125; &#125; 代码说明：@Order注解依然是用来描述执行顺序的，数字越小越优先执行。Run方法的参数是ApplicationArguments对象，如果想从ApplicationArguments对象中获取入口类中main方法接收的参数，调用ApplicationArguments的getNonOptionArgs即可，ApplicationArguments中的getOptionNames方法用来获取项目启动命令行中参数的key 使用下面命令测试： java -jar ***.jar --name=guanyu --age=20 西游记 吴承恩","categories":[],"tags":[]},{"title":"","slug":"Spring-boot数据校验（double check）","date":"2022-10-23T10:35:00.419Z","updated":"2022-10-23T10:18:09.608Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1 、普通校验添加依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-validation&lt;/artifactId> &lt;/dependency> 修改一下idea的配置，防止提示信息乱码项目创建成功后，查看LocalValidatorFactoryBean类的源码，发现默认的ValidationMessageSource（校验出错时的提示文件）是resources目录下的ValidationMessages.properties 文件，如下:因此在resource目录下创建ValidationMessages.properties文件，内容如下： city.cityname.notnull=城市名称必填 city.cityInitial.notnull=城市首字母必填 city.cityInitial.size=首字母长度为1 实体类中配置数据校验 public class City implements Serializable &#123; private static final long serialVersionUID = -40142021265771170L; /** * 主键 自增长 */ private Integer id; /** * 城市名称 */ @NotNull(message=\"&#123;city.cityname.notnull&#125;\") private String cityName; /** * 城市名称拼音 */ private String cityNameSpell; /** * 城市首字母 */ @NotNull(message=\"&#123;city.cityInitial.notnull&#125;\") // @DecimalMin(value = \"1\", message = \"&#123;city.cityInitial.size&#125;\") // @DecimalMax(value = \"1\", message = \"&#123;city.cityInitial.size&#125;\") @Length(min=1,max=1,message = \"&#123;city.cityInitial.size&#125;\") private String cityInitial; private Date createTime; private String creator; private Date operateTime; private String operator; 控制器中加入校验StudentController中加入@Validated: @PostMapping(\"add\") public HttpResult add(@Validated City city)&#123; return HttpResult.ok(\"保存城市信息成功\"); &#125; 默认返回的信息 &#123; \"timestamp\": \"2020-07-27T07:08:41.933+0000\", \"status\": 400, \"error\": \"Bad Request\", \"errors\": [ &#123; \"codes\": [ \"NotNull.city.cityName\", \"NotNull.cityName\", \"NotNull.java.lang.String\", \"NotNull\" ], \"arguments\": [ &#123; \"codes\": [ \"city.cityName\", \"cityName\" ], \"arguments\": null, \"defaultMessage\": \"cityName\", \"code\": \"cityName\" &#125; ], \"defaultMessage\": \"城市名称不允许为空\", \"objectName\": \"city\", \"field\": \"cityName\", \"rejectedValue\": null, \"bindingFailure\": false, \"code\": \"NotNull\" &#125; ], \"message\": \"Validation failed for object='city'. Error count: 1\", \"path\": \"/city/add\" &#125; 使用BindingResult保存校验出错时的的信息 ，StudentController加入 @PostMapping(\"/add\") public HttpResult add(@Validated Student student, BindingResult result)&#123; List&lt;String> errorList=new ArrayList&lt;>(); if(result.hasErrors())&#123; List&lt;ObjectError> list=result.getAllErrors(); for(ObjectError objectError:list)&#123; errorList.add(objectError.getDefaultMessage()); &#125; //下面使用lambda表达式和上面的for作用一样 // result.getAllErrors().forEach( objectError -> errorList.add(objectError.getDefaultMessage())); &#125; if(!errorList.isEmpty())&#123; return HttpResult.error(errorList); &#125; return HttpResult.ok(\"保存城市信息成功\"); &#125; 返回信息 &#123; \"code\": 1000, \"msg\": null, \"data\": [ \"首字母长度为1\", \"城市名称必填\" ]&#125; 2 全局异常处理类（BindException）可以在controller方法中将BindingResult result参数进行删除，进行统一处理 /** * 定义全局异常类 * 全局异常控制类加入拦截 */ @RestControllerAdvice public class GlobalExceptionHandle &#123; @ExceptionHandler(value = BindException.class) public HttpResult bindExceptionErrorHandler(BindException ex) throws Exception &#123; List&lt;String> errorList=new ArrayList&lt;>(); if(ex.hasErrors())&#123; List&lt;ObjectError> list=ex.getAllErrors(); for(ObjectError objectError:list)&#123; errorList.add(objectError.getDefaultMessage()); &#125; // ex.getAllErrors().forEach( objectError -> errorList.add(objectError.getDefaultMessage())); &#125; if(!errorList.isEmpty())&#123; return HttpResult.error(errorList); &#125; return HttpResult.error(); &#125; &#125; 3 、常用注解 4 、全局异常处理类/** * 定义全局异常类 * 全局异常控制类加入拦截 */ @RestControllerAdvice public class GlobalExceptionHandle &#123; @ExceptionHandler(value = BindException.class) public HttpResult bindExceptionErrorHandler(BindException ex) throws Exception &#123; List&lt;String> errorList = new ArrayList&lt;>(); if (ex.hasErrors()) &#123; List&lt;ObjectError> list = ex.getAllErrors(); for (ObjectError objectError : list) &#123; errorList.add(objectError.getDefaultMessage()); &#125; //lambda 表达式写法，和上面的for循环一样 // ex.getAllErrors().forEach( objectError -> errorList.add(objectError.getDefaultMessage())); &#125; if (!errorList.isEmpty()) &#123; return HttpResult.error(errorList); &#125; return HttpResult.error(); &#125; // -----------------------Request------------------------------------------------ @ExceptionHandler(HttpRequestMethodNotSupportedException.class) @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED) public HttpResult handleMethodNotSupportedException(HttpRequestMethodNotSupportedException e) &#123; return HttpResult.error(\"错误的请求方式\"); &#125; @ExceptionHandler(MissingServletRequestParameterException.class) @ResponseStatus(HttpStatus.OK) public HttpResult handleMissingParameterException(MissingServletRequestParameterException e) &#123; return HttpResult.error(\"参数缺失\"); &#125; // ----------------------------data-------------------------------------- @ExceptionHandler(DataAccessException.class) @ResponseStatus(HttpStatus.OK) public HttpResult handlerDataAccessException(DataAccessException e) &#123; return HttpResult.error(31000, \"数据库异常\"); &#125; @ExceptionHandler(EmptyResultDataAccessException.class) @ResponseStatus(HttpStatus.OK) public HttpResult handleDataEmptyException(EmptyResultDataAccessException e) &#123; return HttpResult.error(\"数据不存在\"); &#125; @ExceptionHandler(DuplicateKeyException.class) @ResponseStatus(HttpStatus.OK) public HttpResult handleDataDualException(DuplicateKeyException e) &#123; return HttpResult.error(\"数据重复插入\"); &#125; // @ExceptionHandler(MultipartException.class) // @ResponseStatus(HttpStatus.OK) // public HttpResult handlerMultipartException(Throwable ex) &#123; // String message = \"文件上传错误\"; // MultipartException mEx = (MultipartException) ex; // if (ex.getCause() != null) &#123; // Throwable cause = ex.getCause().getCause(); // if (cause instanceof SizeLimitExceededException) &#123; // SizeLimitExceededException flEx = (FileUploadBase.SizeLimitExceededException) cause; // float permittedSize = flEx.getPermittedSize() / 1024 / 1024; // message = \"文件大小超过\" + permittedSize + \"MB\"; // &#125; else if (cause instanceof FileSizeLimitExceededException) &#123; // FileSizeLimitExceededException flEx = (FileSizeLimitExceededException) mEx.getCause().getCause(); // float permittedSize = flEx.getPermittedSize() / 1024 / 1024; // message = \"文件大小超过\" + permittedSize + \"MB\"; // &#125; // &#125; // // return HttpResult.error(message); // &#125; // ---------All-------------------------------- @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.OK) public HttpResult handlerException(Exception e) &#123; return HttpResult.error(30000, \"系统异常\"); &#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"Spring-boot日期处理","date":"2022-10-23T10:35:00.415Z","updated":"2022-10-23T10:17:06.933Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"Java 8之后，日期类的处理建议使用java.time包中对应的LocalDateTime, LocalDate, LocalTime类。 1、注解@JsonFormat主要是后台到前台的时间格式的转换，即从数据库读取数据到后端的过程，序列化@DateTimeFormat主要是前端到后端的时间格式的转换，反序列化示例： //数据库到后端的转换 @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\") //后端到前端的转换 @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") springboot中默认使用jackson做json序列化和反序列化 2 、全局配置序列化/** * LocalDateTime序列化配置 */ @Configuration public class LocalDateTimeSerializerConfig &#123; /* 如果在配置文件中有spring.jackson.date-format，则取其中的值， 如果没有配置，则为yyyy-MM-dd HH:mm:ss */ @Value(\"$&#123;spring.jackson.date-format:yyyy-MM-dd HH:mm:ss&#125;\") private String pattern; // localDateTime 序列化器 @Bean public LocalDateTimeSerializer localDateTimeSerializer() &#123; return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(pattern)); &#125; @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() &#123; return builder -> builder.serializerByType(LocalDateTime.class, localDateTimeSerializer()); &#125; &#125; 3、日期转换@Configuration public class DateConverterConfig &#123; @Bean public Converter&lt;String, LocalDateTime> LocalDateTimeConvert() &#123; return new Converter&lt;String, LocalDateTime>() &#123; @Override public LocalDateTime convert(String source) &#123; DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"); LocalDateTime date = null; try &#123; date = LocalDateTime.parse(source, df); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return date; &#125; &#125;; &#125; @Bean public Converter&lt;String, LocalDate> LocalDateConvert() &#123; return new Converter&lt;String, LocalDate>() &#123; @Override public LocalDate convert(String source) &#123; DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); LocalDate date = null; try &#123; date = LocalDate.parse(source, df); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return date; &#125; &#125;; &#125; @Bean public Converter&lt;String, LocalTime> LocalTimeConvert() &#123; return new Converter&lt;String, LocalTime>() &#123; @Override public LocalTime convert(String source) &#123; DateTimeFormatter df = DateTimeFormatter.ofPattern(\"HH:mm:ss\"); LocalTime date = null; try &#123; date = LocalTime.parse(source, df); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return date; &#125; &#125;; &#125; &#125; 4、 注意事项实体类必须实现序列化。 对application.yml 配置日期 spring: mvc: date-format: yyyy-MM-dd HH:mm:ss jackson: date-format: yyyy-MM-dd HH:mm:ss","categories":[],"tags":[]},{"title":"","slug":"Spring-boot配置kaptcha验证码","date":"2022-10-23T10:35:00.411Z","updated":"2022-10-23T10:18:20.131Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1 创建springboot工程2 pom中引入相关依赖&lt;dependency> &lt;groupId>com.github.penggle&lt;/groupId> &lt;artifactId>kaptcha&lt;/artifactId> &lt;version>2.3.2&lt;/version> &lt;/dependency> 3 三种实现方式3.1 第一种使用xml文件配置属性resources下新建kaptcha.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;bean id=\"captchaProducer\" class=\"com.google.code.kaptcha.impl.DefaultKaptcha\"> &lt;property name=\"config\"> &lt;bean class=\"com.google.code.kaptcha.util.Config\"> &lt;constructor-arg type=\"java.util.Properties\"> &lt;props> &lt;prop key =\"kaptcha.border\">yes&lt;/prop> &lt;prop key=\"kaptcha.border.color\">105,179,90&lt;/prop> &lt;prop key=\"kaptcha.textproducer.font.color\">blue&lt;/prop> &lt;prop key=\"kaptcha.image.width\">100&lt;/prop> &lt;prop key=\"kaptcha.image.height\">50&lt;/prop> &lt;prop key=\"kaptcha.textproducer.font.size\">27&lt;/prop> &lt;prop key=\"kaptcha.session.key\">code&lt;/prop> &lt;prop key=\"kaptcha.textproducer.char.length\">4&lt;/prop> &lt;prop key=\"kaptcha.textproducer.font.names\">宋体,楷体,微软雅黑&lt;/prop> &lt;prop key=\"kaptcha.textproducer.char.string\">0123456789ABCEFGHIJKLMNOPQRSTUVWXYZ&lt;/prop> &lt;prop key=\"kaptcha.obscurificator.impl\">com.google.code.kaptcha.impl.WaterRipple&lt;/prop> &lt;prop key=\"kaptcha.noise.color\">black&lt;/prop> &lt;prop key=\"kaptcha.noise.impl\">com.google.code.kaptcha.impl.DefaultNoise&lt;/prop> &lt;prop key=\"kaptcha.background.clear.from\">185,56,213&lt;/prop> &lt;prop key=\"kaptcha.background.clear.to\">white&lt;/prop> &lt;prop key=\"kaptcha.textproducer.char.space\">3&lt;/prop> &lt;/props> &lt;/constructor-arg> &lt;/bean> &lt;/property> &lt;/bean> &lt;/beans> 启动类加入@ImportResource注解 @SpringBootApplication @ImportResource(locations=&#123;\"classpath:kaptcha.xml\"&#125;) public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; &#125; com.xja.controller 包中创建测试controller /** * 生成验证码并把验证码存储到session中 */ @Controller public class CodeController &#123; @Autowired private Producer captchaProducer = null; @GetMapping(\"/kaptcha\") public void getKaptchaImage(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpSession session = request.getSession(); response.setDateHeader(\"Expires\", 0); response.setHeader(\"Cache-Control\", \"no-store, no-cache, must-revalidate\"); response.addHeader(\"Cache-Control\", \"post-check=0, pre-check=0\"); response.setHeader(\"Pragma\", \"no-cache\"); response.setContentType(\"image/jpeg\"); //生成验证码 String capText = captchaProducer.createText(); session.setAttribute(Constants.KAPTCHA_SESSION_KEY, capText); //向客户端写出 BufferedImage bi = captchaProducer.createImage(capText); ServletOutputStream out = response.getOutputStream(); ImageIO.write(bi, \"jpg\", out); try &#123; out.flush(); &#125; finally &#123; out.close(); &#125; &#125; &#125; 3.2 第二种使用配置bean配置属性com.xja.config 下新建 KaptchaConfig @Component public class KaptchaConfig &#123; @Bean public DefaultKaptcha getDefaultKaptcha()&#123; com.google.code.kaptcha.impl.DefaultKaptcha defaultKaptcha = new com.google.code.kaptcha.impl.DefaultKaptcha(); Properties properties = new Properties(); properties.setProperty(\"kaptcha.border\", \"yes\"); properties.setProperty(\"kaptcha.border.color\", \"105,179,90\"); properties.setProperty(\"kaptcha.textproducer.font.color\", \"blue\"); properties.setProperty(\"kaptcha.image.width\", \"110\"); properties.setProperty(\"kaptcha.image.height\", \"40\"); properties.setProperty(\"kaptcha.textproducer.font.size\", \"30\"); properties.setProperty(\"kaptcha.session.key\", \"code\"); properties.setProperty(\"kaptcha.textproducer.char.length\", \"6\"); properties.setProperty(\"kaptcha.textproducer.font.names\", \"宋体,楷体,微软雅黑\"); Config config = new Config(properties); defaultKaptcha.setConfig(config); return defaultKaptcha; &#125; &#125; 3.3 第三种使用配置bean，验证码属性使用验证码属性进行配置建议使用第三种方法 resources下新建 kaptcha.properties ##### Kaptcha Information kaptcha.width=150 kaptcha.height=42 kaptcha.border=no kaptcha.textproducer.font.size=40 kaptcha.textproducer.char.space=10 kaptcha.textproducer.font.names=\\u4EFF\\u5B8B,\\u5FAE\\u8F6F\\u96C5\\u9ED1 kaptcha.textproducer.char.string=1234567890 kaptcha.textproducer.char.length=4 kaptcha.background.clear.from=92,189,170 kaptcha.background.clear.to=255,255,255 KaptchaConfig修改成从属性文件中读取 @Component public class KaptchaConfig1 &#123; private static Properties props = new Properties(); @Bean public DefaultKaptcha defaultKaptcha() throws Exception &#123; // 创建DefaultKaptcha对象 DefaultKaptcha defaultKaptcha = new DefaultKaptcha(); // 读取配置文件 try &#123; props.load(KaptchaConfig1.class.getClassLoader() .getResourceAsStream(\"kaptcha.properties\")); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; // 将Properties文件设到DefaultKaptcha对象中 defaultKaptcha.setConfig(new Config(props)); return defaultKaptcha; &#125; &#125; 运行后，输入http://localhost:8080/kaptcha了解hutool的验证码：https://www.hutool.cn/docs/#/captcha/%E6%A6%82%E8%BF%B0?id=circlecaptcha-%e5%9c%86%e5%9c%88%e5%b9%b2%e6%89%b0%e9%aa%8c%e8%af%81%e7%a0%81","categories":[],"tags":[]},{"title":"","slug":"Spring-boot集成Thymeleaf","date":"2022-10-23T10:35:00.405Z","updated":"2022-10-23T10:17:41.250Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"Thymeleaf 是新一代Java模板引擎，类似于FreeMarker等传统Java模板引擎，与传统引擎不同的是，Thymeleaf支持HTML原型，即可以让前端工程师在浏览器中直接打开查看样式，也可以让后端工程师结合真实数据查看显示效果。 1 、创建springboot工程2 、添加依赖&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> 3 、配置Thymeleafapplication.properties 中配置 #是否开启缓存，开发时可设置为false，默认为true spring.thymeleaf.cache=false #是否检查模板是否存在，默认为true spring.thymeleaf.check-template=true #是否检查模板位置是否存在，默认为true spring.thymeleaf.check-template-location=true #模板文件编码 spring.thymeleaf.encoding=UTF-8 #模板文件位置 spring.thymeleaf.prefix=classpath:/templates/ #Content-Type配置 spring.thymeleaf.servlet.content-type=text/html #模板文件后缀 spring.thymeleaf.suffix=.html 4、创建实体类、控制器实体类参考： public class Book &#123; private Integer id; private String name; private String author; // getter/setter 自行生成 &#125; 控制类参考： @Controller public class BookController &#123; @GetMapping(\"/books\") public ModelAndView books() &#123; List&lt;Book> books = new ArrayList&lt;>(); Book b1 = new Book(); b1.setId(1); b1.setAuthor(\"罗贯中\"); b1.setName(\"三国演义\"); Book b2 = new Book(); b2.setId(2); b2.setAuthor(\"曹雪芹\"); b2.setName(\"红楼梦\"); books.add(b1); books.add(b2); ModelAndView mv = new ModelAndView(); mv.addObject(\"books\", books); mv.setViewName(\"books\"); return mv; &#125; &#125; 5 、创建视图templates/books.html &lt;!DOCTYPE html> &lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>图书列表&lt;/title> &lt;/head> &lt;body> &lt;table border=\"1\"> &lt;tr> &lt;td>图书编号&lt;/td> &lt;td>图书名称&lt;/td> &lt;td>图书作者&lt;/td> &lt;/tr> &lt;tr th:each=\"book:$&#123;books&#125;\"> &lt;td th:text=\"$&#123;book.id&#125;\">&lt;/td> &lt;td th:text=\"$&#123;book.name&#125;\">&lt;/td> &lt;td th:text=\"$&#123;book.author&#125;\">&lt;/td> &lt;/tr> &lt;/table> &lt;/body> 6 、运行","categories":[],"tags":[]},{"title":"","slug":"Spring-boot集成Swagger2","date":"2022-10-23T10:35:00.401Z","updated":"2022-10-23T10:17:14.167Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1、引入依赖&lt;!-- swagger 依赖jar --> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger2&lt;/artifactId> &lt;version>2.9.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger-ui&lt;/artifactId> &lt;version>2.9.2&lt;/version> &lt;/dependency> 2、添加swagger配置文件package com.xja.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @EnableSwagger2 @Configuration public class Swagger2Config &#123; @Bean public Docket createRestApi() &#123; /** // 添加请求参数，我们这里把token作为请求头部参数传入后端 ParameterBuilder parameterBuilder = new ParameterBuilder(); List&lt;Parameter> parameters = new ArrayList&lt;>(); parameterBuilder.name(\"token\").description(\"令牌\") .modelRef(new ModelRef(\"string\")).parameterType(\"header\").required(false).build(); //header中的token参数非必填，传空也可以 parameters.add(parameterBuilder.build()); */ return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //为当前包路径 .apis(RequestHandlerSelectors.basePackage(\"edu.xja.controller\")) .paths(PathSelectors.any()) .build(); //.build().globalOperationParameters(parameters); &#125; //构建 api文档的详细信息函数 private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() //页面标题 .title(\"Spring Boot集成Swagger2构建RESTful API\") //创建人 .contact(new Contact(\"Thomas\", \"http://www.nynu.edu.cn\", \"thomas@163.com\")) //版本号 .version(\"1.9\") //描述 .description(\"演示系统API描述\") .build(); &#125; &#125; 注意事项：上面代码Contact 类引入的是： import springfox.documentation.service.Contact; 代码解释：Ø 通过@EnableSwagger2 注解开启swagger2Ø 要配置一个Docket BeanØ 在.apis 方法中配置扫描controller的位置Ø apinInfo方法中设置文档的基本信息，比如标题、联系人、版本、描述等 打开浏览器，地址栏中输入：localhost:8888/swagger-ui.html注：若启动不了，尝试在application启动类上加入注解@EnableSwagger2 3、Swagger主要注解3.1、@Api@Api 用在类上，说明该类的作用。可以标记一个Controller类做为swagger 文档资源最重要是属性是tags，示例： @Api(tags =&#123;\"学生管理Api\"&#125;) 3.2、@ApiModel@ApiModel用在类上，表示对类进行说明，用于实体类中的参数接收说明最重要的属性如下，示例： @ApiModel(value=\"学生实体类\",description = \"学生实体类信息\") 3.3、@ApiModelProperty**@ApiModelProperty()**用于字段,表示对model属性的说明最重要的属性，示例： @ApiModelProperty(value=\"学生姓名\",required = true) 3.4、@ApiParam@ ApiParam用于Controller中方法的参数说明 3.5、@ApiOperation@ApiOperation用在Controller里的方法上，说明方法的作用，每一个接口的定义,使用方式如下： @ApiOperation(value=\"根据主键获取学生信息\",notes=\"输入学生主键，获取学生信息\") 3.6、@ApiResponse和ApiResponses@ApiImplicitParams(&#123;@ApiImplicitParam(value=\"主键ID\",name=\"id\")&#125;)","categories":[],"tags":[]},{"title":"","slug":"Spring-boot集成MyBatis","date":"2022-10-23T10:35:00.397Z","updated":"2022-10-23T10:17:33.256Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1、添加依赖：&lt;!-- mysql 依赖jar，只添加mysql依赖可以不配置数据源 --> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.26&lt;/version> &lt;/dependency> &lt;!-- mybatis 依赖jar，添加mybatis起步依赖，必须配置数据源 --> &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>2.2.0&lt;/version> &lt;/dependency> 2、修改配置文件application.yml添加数据源配置和MyBatis配置 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/student?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8 # 使用mysql8的驱动 要加上&amp;serverTimezone=Asia/Shanghai username: root password: root #mybatis配置 mybatis: mapper-locations: classpath:mapper/*.xml # config-location: classpath:mybatis-config.xml type-aliases-package: edu.xja.entity configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #mybatis配置 #mybatis: #typeAliasesPackage: edu.xja.domain #mapperLocations: classpath:mapping/*.xml #configLocation: classpath:/mybatis-config.xml 代码解释：Yml配置文件也支持驼峰模式，看上面的注释，理解一下Mysql8 url 配置加上时区：serverTimezone=Asia/Shanghai 3、创建启动类进行测试@SpringBootApplication public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class,args); &#125; &#125; 创建Dao层，Service层进行测试，暂不赘述。","categories":[],"tags":[]},{"title":"","slug":"Spring-boot集成JWT","date":"2022-10-23T10:35:00.393Z","updated":"2022-10-23T10:17:24.208Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"JWT是什么：JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑且独立的方式，用于在各方之间作为JSON对象安全地传输信息。Ø 官方网址：https://jwt.io/Ø 调试页面：https://jwt.io/Ø 学习文档：https://jwt.io/introduction/ 用途：Ø 授权：这是我们使用JWT最广泛的应用场景。一次用户登录，后续请求将会包含JWT，对于那些合法的token，允许用户连接路由，服务和资源。目前JWT广泛应用在SSO（Single Sign On）(单点登录)上。因为他们开销很小并且可以在不同领域轻松使用。Ø 信息交换：JSON Web Token是一种在各方面之间安全信息传输的好的方式 因为JWT可以签名 - 例如，使用公钥/私钥对 - 您可以确定发件人是他们所说的人。 此外，由于使用标头和有效负载计算签名，您还可以验证内容是否未被篡改。 组成：一个JWT由三部分组成，各部分以点分隔： | Header(头部）—–base64编码的Json字符串Payload(载荷）—base64编码的Json字符串Signature(签名)—使用指定算法，通过Header和Playload加盐计算的字符串 || — | 一个JWT看起来像下面这样： xxxxx.yyyyy.zzzzz header此部分有两部分组成：Ø 一部分是token的类型，目前只能是JWTØ 另一部分是签名算法，比如HMAC 、 SHA256 、 RSA示例： | {“alg”:”HS256”,“typ”:”JWT”} || — | base64编码命令： | echo -n ‘{“alg”:”HS256”,”typ”:”JWT”}’ &#124; base64或者echo -n “{\\“alg\\“:\\“HS256\\“,\\“typ\\“:\\“JWT\\“}” &#124; base64 || — | Payloadtoken的第二部分是payload（有效负载），其中包含claims（声明）。Claims是关于一个实体（通常是用户）和其他数据类型的声明。claims有三种类型：registered,public,and private claims。 Ø Registered（已注册的声明）：这些是一组预定义声明，不是强制性的，但建议使用，以提供一组有用的，可互操作的声明。 其中一些是：iss（发行人），exp（到期时间），sub（主题），aud（观众）and others。（请注意，声明名称只有三个字符，因为JWT意味着紧凑。）Ø Public(公开声明)：这些可以由使用JWT的人随意定义。 但为避免冲突，应在IANA JSON Web Token Registry中定义它们，或者将其定义为包含防冲突命名空间的URI。Ø private (私人声明)：这些声明是为了在同意使用它们的各方之间共享信息而创建的，并且既不是注册声明也不是公开声明。 Signature要创建签名部分，您需要使用base64编码后的header，base64编码后的payload，a secret，标头中指定的算法，并对其进行签名。示例： | HMACSHA256(base64UrlEncode(header) + “.” +base64UrlEncode(payload),secret) || — | Base64和Base64Url 的区别Base64Url在Base64的基础上进行以下处理： 去除了尾部填充的“=” 把“+”替换成“-” 斜线“/”替换成下划线“_” Spring-boot集成导入依赖： &lt;dependency> &lt;groupId>com.auth0&lt;/groupId> &lt;artifactId>java-jwt&lt;/artifactId> &lt;version>4.0.0&lt;/version> &lt;/dependency> 编写JwtUtil： @Component @Slf4j public class JwtUtil &#123; /** * 创建token * @return */ public String createToken() &#123; // token 密钥 String secret = \"123456\"; //签名算法 Algorithm algorithm = Algorithm.HMAC256(secret); // 头部信息 Map&lt;String, Object> map = new HashMap&lt;>(); //JWT 的签名算法 map.put(\"alg\", \"HS256\"); //token的类型 map.put(\"typ\", \"JWT\"); //获取当前时间 long currentTime = System.currentTimeMillis();// + 30 * 60 * 1000; //获取当前日期 Date nowDate = new Date(currentTime); //当前时间加上30分钟 Date expireDate = new Date(currentTime + 30 * 60 * 1000);// 半小时过期 //创建token String token = JWT.create() .withHeader(map)// 设置头部信息 Header .withIssuer(\"Thomas\")//设置 载荷 签名是有谁生成 例如 服务器 .withSubject(\"this is test token\")//设置 载荷 签名的主题 // .withNotBefore(new Date())//设置 载荷 定义在什么时间之前，该jwt都是不可用的. .withAudience(\"APP\")//设置 载荷 签名的观众 也可以理解谁接受签名的 .withIssuedAt(nowDate) //设置 载荷 生成签名的时间 .withExpiresAt(expireDate)//设置 载荷 签名过期的时间 .sign(algorithm);//签名 Signature log.info(\"生成的JWT 为：\"+token); return token; &#125; /** * 校验token * @param token * @throws UnsupportedEncodingException */ public void verifyToken(String token) throws UnsupportedEncodingException &#123; // token 密钥 String secret = \"123456\"; Algorithm algorithm = Algorithm.HMAC256(secret); JWTVerifier verifier = JWT.require(algorithm).withIssuer(\"Thomas\").build(); // Reusable verifier instance try &#123; DecodedJWT jwt = verifier.verify(token); String subject = jwt.getSubject(); List&lt;String> audience = jwt.getAudience(); Map&lt;String, Claim> claims = jwt.getClaims(); for (Map.Entry&lt;String, Claim> entry : claims.entrySet()) &#123; String key = entry.getKey(); Claim claim = entry.getValue(); System.out.println(\"key:\" + key + \" value:\" + claim.asString()); &#125; // Claim claim = claims.get(\"loginName\"); // // System.out.println(claim.asString()); // System.out.println(subject); // System.out.println(audience.get(0)); &#125;catch(Exception ex)&#123; System.out.println(\"验证失败！！\"); &#125; &#125; public String createTokenWithChineseClaim() &#123; long currentTime = System.currentTimeMillis();// + 30 * 60 * 1000; Date nowDate = new Date(currentTime); Date expireDate = new Date(currentTime+ 30 * 60 * 1000);// 半小时过期 Map&lt;String, Object> map = new HashMap&lt;String, Object>(); map.put(\"alg\", \"HS256\"); map.put(\"typ\", \"JWT\"); Algorithm algorithm = Algorithm.HMAC256(\"secret\"); String token = JWT.create().withHeader(map) /* 设置 载荷 Payload */ .withClaim(\"loginName\", \"zhuoqianmingyue\").withClaim(\"userName\", \"张三\").withClaim(\"deptName\", \"技术部\") .withIssuer(\"SERVICE\")// 签名是有谁生成 例如 服务器 .withSubject(\"this is test token\")// 签名的主题 // .withNotBefore(new Date())//定义在什么时间之前，该jwt都是不可用的 .withAudience(\"APP\")// 签名的观众 也可以理解谁接受签名的 .withIssuedAt(nowDate) // 生成签名的时间 .withExpiresAt(expireDate)// 签名过期的时间 /* 签名 Signature */ .sign(algorithm); return token; &#125; // public String createTokenWithChineseClaim2() throws UnsupportedEncodingException &#123; // // long currentTime = System.currentTimeMillis();// + 30 * 60 * 1000; // // Date nowDate = new Date(currentTime); // // // Date expireDate = new Date(currentTime+ 30 * 60 * 1000);// 半小时过期 // //生产头部信息 // Map&lt;String, Object> map = new HashMap&lt;String, Object>(); // map.put(\"alg\", \"HS256\"); // map.put(\"typ\", \"JWT\"); // // Member member = new Member(); // member.setMemberAccount(\"admin\"); // member.setMemberName(\"张三\"); // // Gson gson = new Gson(); // // // String userJson = gson.toJson(member); // // // String userJsonBase64 = BaseEncoding.base64().encode(userJson.getBytes()); // // Algorithm algorithm = Algorithm.HMAC256(\"secret\"); // String token = JWT.create().withHeader(map) // // .withClaim(\"loginName\", \"zhuoqianmingyue\").withClaim(\"user\", userJsonBase64).withIssuer(\"SERVICE\")// 签名是有谁生成 // .withSubject(\"this is test token\")// 签名的主题 // // .withNotBefore(new Date())//该jwt都是不可用的时间 // .withAudience(\"APP\")// 签名的观众 也可以理解谁接受签名的 // .withIssuedAt(nowDate) // 生成签名的时间 // .withExpiresAt(expireDate)// 签名过期的时间 // .sign(algorithm);//签名 Signature // // return token; // // &#125; &#125; 编写测试类： @SpringBootTest @RunWith(SpringRunner.class) public class JwtUtilTest &#123; @Resource private JwtUtil jwtUtil; @Test public void createToken() &#123; jwtUtil.createToken(); &#125; @Test public void verifyToken() &#123; String token=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0aGlzIGlzIHRlc3QgdG9rZW4iLCJhdWQiOiJBUFAiLCJpc3MiOiJUaG9tYXMiLCJleHAiOjE2MTkwNzM5NTAsImlhdCI6MTYxOTA3MjE1MH0.7Os9SyBdsFbEgMZoG6ZwOlqqgx0qpbk36B2AOKKixXY\"; try &#123; jwtUtil.verifyToken(token); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"Spring-boot集成druid","date":"2022-10-23T10:35:00.389Z","updated":"2022-10-23T10:18:27.906Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1 介绍1.1数据库连接池介绍数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是在重新建立一个，通过数据库连接池能明显提高对数据库操作的性能。在Java应用程序中，常用的数据库连接池有DBCP、C3P0、Proxool、Druid等 1.2 数据库连接池性能比较参考：https://blog.csdn.net/u011389515/article/details/76578129 1.3 Druid介绍Druid 是阿里开源的一个JDBC应用组件，提供了非常优秀的数据库监控和扩展功能。网址：Druid：https://github.com/alibaba/druid/ 2集成Springboot 默认数据库连接池 hikari 2.1加入依赖&lt;!--druid--> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid-spring-boot-starter&lt;/artifactId> &lt;version>1.2.8&lt;/version> &lt;/dependency> 2.2 添加配置修改配置文件，将原有的数据源配置替换成Druid数据源并配置数据源相关参数。 spring: datasource: name: druidDataSource type: com.alibaba.druid.pool.DruidDataSource druid: # JDBC 配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatis_plus_demo?useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true&amp;characterEncoding=utf-8 username: root password: root filters: stat,wall # filters: stat,wall,log4j,config #连接池配置 max-active: 100 initial-size: 1 max-wait: 60000 min-idle: 1 time-between-eviction-runs-millis: 60000 min-evictable-idle-time-millis: 300000 validation-query: select 'x' test-while-idle: true test-on-borrow: false test-on-return: false pool-prepared-statements: true max-open-prepared-statements: 50 max-pool-prepared-statement-per-connection-size: 20 2.3 自定义属性配置如果需要通过定制的配置文件对Druid进行自定义属性配置，添加配置类如下：edu.xja.config 包下新建一个DruidDataSourceProperties 类 /** * 数据源属性 */ @ConfigurationProperties(prefix = \"spring.datasource.druid\") public class DruidDataSourceProperties &#123; // jdbc private String driverClassName; private String url; private String username; private String password; // jdbc connection pool private int initialSize; private int minIdle; private int maxActive = 100; private long maxWait; private long timeBetweenEvictionRunsMillis; private long minEvictableIdleTimeMillis; private String validationQuery; private boolean testWhileIdle; private boolean testOnBorrow; private boolean testOnReturn; private boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; // filter private String filters; public int getInitialSize() &#123; return initialSize; &#125; public void setInitialSize(int initialSize) &#123; this.initialSize = initialSize; &#125; public int getMinIdle() &#123; return minIdle; &#125; public void setMinIdle(int minIdle) &#123; this.minIdle = minIdle; &#125; public int getMaxActive() &#123; return maxActive; &#125; public void setMaxActive(int maxActive) &#123; this.maxActive = maxActive; &#125; public long getMaxWait() &#123; return maxWait; &#125; public void setMaxWait(long maxWait) &#123; this.maxWait = maxWait; &#125; public long getTimeBetweenEvictionRunsMillis() &#123; return timeBetweenEvictionRunsMillis; &#125; public void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) &#123; this.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis; &#125; public long getMinEvictableIdleTimeMillis() &#123; return minEvictableIdleTimeMillis; &#125; public void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) &#123; this.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis; &#125; public String getValidationQuery() &#123; return validationQuery; &#125; public void setValidationQuery(String validationQuery) &#123; this.validationQuery = validationQuery; &#125; public boolean isTestWhileIdle() &#123; return testWhileIdle; &#125; public void setTestWhileIdle(boolean testWhileIdle) &#123; this.testWhileIdle = testWhileIdle; &#125; public boolean isTestOnBorrow() &#123; return testOnBorrow; &#125; public void setTestOnBorrow(boolean testOnBorrow) &#123; this.testOnBorrow = testOnBorrow; &#125; public boolean isTestOnReturn() &#123; return testOnReturn; &#125; public void setTestOnReturn(boolean testOnReturn) &#123; this.testOnReturn = testOnReturn; &#125; public boolean isPoolPreparedStatements() &#123; return poolPreparedStatements; &#125; public void setPoolPreparedStatements(boolean poolPreparedStatements) &#123; this.poolPreparedStatements = poolPreparedStatements; &#125; public int getMaxPoolPreparedStatementPerConnectionSize() &#123; return maxPoolPreparedStatementPerConnectionSize; &#125; public void setMaxPoolPreparedStatementPerConnectionSize(int maxPoolPreparedStatementPerConnectionSize) &#123; this.maxPoolPreparedStatementPerConnectionSize = maxPoolPreparedStatementPerConnectionSize; &#125; public String getFilters() &#123; return filters; &#125; public void setFilters(String filters) &#123; this.filters = filters; &#125; public String getDriverClassName() &#123; return driverClassName; &#125; public void setDriverClassName(String driverClassName) &#123; this.driverClassName = driverClassName; &#125; public String getUrl() &#123; return url; &#125; public void setUrl(String url) &#123; this.url = url; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 2.4 config包下配置Servlet和FilterConfig包下新建一个DruidConfig配置类，主要是注入属性和配置连接池相关的配置，如黑白名单、监控管理后台登录账户密码等 /** * Druid数据源配置 */ @Configuration @EnableConfigurationProperties(&#123;DruidDataSourceProperties.class&#125;) public class DruidConfig &#123; @Autowired private DruidDataSourceProperties properties; @Bean @ConditionalOnMissingBean public DataSource druidDataSource() &#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setDriverClassName(properties.getDriverClassName()); druidDataSource.setUrl(properties.getUrl()); druidDataSource.setUsername(properties.getUsername()); druidDataSource.setPassword(properties.getPassword()); druidDataSource.setInitialSize(properties.getInitialSize()); druidDataSource.setMinIdle(properties.getMinIdle()); druidDataSource.setMaxActive(properties.getMaxActive()); druidDataSource.setMaxWait(properties.getMaxWait()); druidDataSource.setTimeBetweenEvictionRunsMillis(properties.getTimeBetweenEvictionRunsMillis()); druidDataSource.setMinEvictableIdleTimeMillis(properties.getMinEvictableIdleTimeMillis()); druidDataSource.setValidationQuery(properties.getValidationQuery()); druidDataSource.setTestWhileIdle(properties.isTestWhileIdle()); druidDataSource.setTestOnBorrow(properties.isTestOnBorrow()); druidDataSource.setTestOnReturn(properties.isTestOnReturn()); druidDataSource.setPoolPreparedStatements(properties.isPoolPreparedStatements()); druidDataSource.setMaxPoolPreparedStatementPerConnectionSize(properties.getMaxPoolPreparedStatementPerConnectionSize()); try &#123; druidDataSource.setFilters(properties.getFilters()); druidDataSource.init(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return druidDataSource; &#125; /** * 注册Servlet信息， 配置监控视图 * * @return */ @Bean @ConditionalOnMissingBean public ServletRegistrationBean&lt;Servlet> druidServlet() &#123; ServletRegistrationBean&lt;Servlet> servletRegistrationBean = new ServletRegistrationBean&lt;Servlet>(new StatViewServlet(), \"/druid/*\"); //白名单： // servletRegistrationBean.addInitParameter(\"allow\",\"127.0.0.1,139.196.87.48\"); //IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not permitted to view this page. servletRegistrationBean.addInitParameter(\"deny\",\"192.168.1.119\"); //登录查看信息的账号密码, 用于登录Druid监控后台 servletRegistrationBean.addInitParameter(\"loginUsername\", \"admin\"); servletRegistrationBean.addInitParameter(\"loginPassword\", \"admin\"); //是否能够重置数据. servletRegistrationBean.addInitParameter(\"resetEnable\", \"true\"); return servletRegistrationBean; &#125; /** * 注册Filter信息, 监控拦截器 * * @return */ @Bean @ConditionalOnMissingBean public FilterRegistrationBean&lt;Filter> filterRegistrationBean() &#123; FilterRegistrationBean&lt;Filter> filterRegistrationBean = new FilterRegistrationBean&lt;Filter>(); filterRegistrationBean.setFilter(new WebStatFilter()); filterRegistrationBean.addUrlPatterns(\"/*\"); filterRegistrationBean.addInitParameter(\"exclusions\", \"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\"); return filterRegistrationBean; &#125; &#125; 3 查看监控3.1 登录页面http://localhost:9999/druid/login.html 3.2监控首页","categories":[],"tags":[]},{"title":"","slug":"Springboot 集成JavaMail","date":"2022-10-23T10:35:00.385Z","updated":"2022-10-23T10:18:41.199Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"引入依赖：&lt;!--javaMail--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-mail&lt;/artifactId> &lt;/dependency> 配置application.yml spring: mail: host: smtp.qq.com username: ****@qq.com password: 授权码 properties: mail: smtp: auth: true starttls: enable: true # 注意修改下面这句为false ，否则会报错，不能发送邮件 required: false util 下新建SendMail类 @Component public class SendMail &#123; //发送普通文本格式邮件 public static void sendTextMail(MimeMessage message, String username, String recipient, String subject, List&lt;String> content)&#123; try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(username); helper.setTo(recipient); helper.setSubject(subject); StringBuffer sb = new StringBuffer(); sb.append(content); helper.setText(sb.toString()); &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; &#125; //发送html格式邮件 public void sendHtmlMail(MimeMessage message, String username, String recipient, String subject, String content) &#123; try &#123; //true表示需要创建一个multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(username); helper.setTo(recipient); helper.setSubject(subject); helper.setText(content, true); System.out.println(\"html格式邮件发送中...\"); &#125; catch (MessagingException e) &#123; System.out.println(\"html格式邮件发送失败！\"); &#125; &#125; &#125; 测试： @RunWith(SpringRunner.class) @SpringBootTest public class SendMailTest &#123; @Resource private JavaMailSender javaMailSender; @Resource private SendMail sendMail; @Test public void sendTextMail() &#123; MimeMessage message = javaMailSender.createMimeMessage(); List&lt;String> strList=new ArrayList&lt;>(); strList.add(\"第一行\"); strList.add(\"第二行\"); sendMail.sendTextMail(message,\"****6@qq.com\",\"****@qq.com\",\"test 888\",strList); javaMailSender.send(message); &#125; @Test public void sendHtmlMail() &#123; try &#123; MimeMessage message = javaMailSender.createMimeMessage(); String content = \"&lt;a href=\\\"http://www.baidu.com\\\">单击激活[公交查询网站]&lt;/a>\"; sendMail.sendHtmlMail(message, \"*****6@sina.com\", \"3196443411@qq.com\", \"激活邮件\", content); javaMailSender.send(message); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"RabbitMQ工作模式","date":"2022-10-23T10:35:00.381Z","updated":"2022-10-23T10:21:25.599Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"simple模式 生产者产生消息，将消息放入队列，消费者监听消息队列，如果队列中有消息就消费掉，消息被拿走后会自动从队列中删除，存在隐患需要消费者设置ACK确认，消费者处理完后要及时发送ack给队列，否则会造成内存溢出。简单队列的不足：耦合性过高，生产者一一对应消费者，如果有多个消费者想消费队列中信息就无法实现了。 work工作模式(资源的竞争) 生产者将消息放入队列，消费者可以有多个。一般有两种模式： **轮询分发(round-robin)**：MQ不管两个消费者谁忙，数据总是你一个我一个，MQ 给两个消费发数据的时候是不知道消费者性能的，默认就是雨露均沾。此时 autoAck = true。 公平分发：要让消费者消费完毕一条数据后就告知MQ，再让MQ发数据即可。自动应答要关闭，实现按照消费者性能消费。 fanout publish/subscribe 发布订阅模式 类似公众号的订阅跟发布，属于 fanout 模式，不处理路由键。不需要指定routingKey，我们只需要把队列绑定到交换机， 消息就会被发送到所有到队列中： 一个生产者多个消费者 每一个消费者都有一个自己的队列 生产者没有把消息直接发送到队列而是发送到了交换机转化器(exchange)。 每一个队列都要绑定到交换机上。 生产者发送的消息经过交换机到达队列，从而实现一个消息被多个消费者消费。 direct routing 路由模式direct：处理路由键，需要指定routingKey，此时生产者发送数据到MQ的时候会指定key，任务队列也会指定key，只有key一样消息才会被传送到队列中。如下图 缺点：路由key必须要明确，无法实现规则性模糊匹配。 topic 主题模式将路由键跟某个模式匹配，生产者会带 routingKey，但是消费者的MQ会带模糊routingKey： 表示匹配 &gt;=1个字符。 表示匹配一个。 路由功能添加模糊匹配。 消息产生者产生消息，把消息交给交换机。 交换机根据key的规则模糊匹配到对应的队列，由队列的监听消费者接收消息消费。","categories":[],"tags":[]},{"title":"","slug":"MyBatis-Spring","date":"2022-10-23T10:35:00.377Z","updated":"2022-10-23T10:15:28.878Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"编写数据源配置 &lt;bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"> &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/> &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/数据库名称?usesSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8\"/> &lt;property name=\"username\" value=\"root\"/> &lt;property name=\"password\" value=\"root\"/> &lt;/bean> sqlSessionFactory &lt;!--sqlSessionFactory--> &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> &lt;property name=\"dataSource\" ref=\"datasource\"/> &lt;!--绑定MyBatis配置文件--> &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/> &lt;property name=\"mapperLocations\" value=\"classpath:com/xja/mapper/*.xml\"/> &lt;/bean> sqlSessionTemplate &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"> &lt;!--只能用构造器注入sqlSessionFactory,因为他没有set方法--> &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/> &lt;/bean> 需要给接口加实现类 将自己写的实现类，注入Spring中 新创建spring-beans.xml 测试使用即可！&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> &lt;import resource=\"applicationContext.xml\"/> &lt;bean id=\"userMapper\" class=\"com.xja.mapper.UserMapperImpl\"> &lt;property name=\"sqlSession\" ref=\"sqlSession\"/> &lt;/bean> &lt;/beans>","categories":[],"tags":[]},{"title":"","slug":"JSON处理时间","date":"2022-10-23T10:35:00.373Z","updated":"2022-10-23T10:13:55.296Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"objectMapper mapper = new objectMapper(); //如何让他不返回时间戳!所以我们要关闭它的时间戳功能 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //2.时间格式化问题!自定日期格式对象; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MN-dd HH:mm:ss\"); //3.ilmapper指定时间日期格式为simpleDateFormat; mapper.setDateFormat(sdf); //写一个日期对象 Date date = new Date(); return mapper.writevalueAsString(date); 可以对其进行封装成工具类 import com.fasterxml.jackson.core. JsonProcessingException; import com.fasterxml.jackson.databind.objectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import java.text.SimpleDateFormat; public class JsonUtils &#123; public static string getjson(object object)&#123; return getJson(object, dateFormat: \"yyyy-MM-dd HH :mm: ss\"); &#125; public static string getjson(object object,string dateFormat)&#123; objectMapper mapper = new ObjectMapper(); //1.如何让他不返回时间激!所以我们要关闭它的时间戳功能 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false) ; //2.时间格式化问题!自定日期格式对象; simpleDateFormat sdf = new SimpleDateFormat(dateFormat) ; //3.ilmapper指定时间日期格式为simpleDateFormat ; mapper.setDateFormat(sdf) ; try&#123; return mapper.writevalueAsString(object); &#125; catch (JsonProcessingException e) &#123; e.printstackTrace(); &#125; return null; &#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"AOP实现代理的三种方式","date":"2022-10-23T10:35:00.369Z","updated":"2022-10-23T10:14:34.591Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"前提：加入命名空间xmlns:aop=\"http://www.springframework.org/schema/aop\" ============================================================ http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd 1、使用原生Spring API接口：&lt;!--方式一：使用原生Spring API接口--> &lt;!--配置aop需要导入aop的约束--> &lt;aop:config> &lt;!--切入点：expression：表达式，execution(要执行的位置！****)--> &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.xja.service.impl.UserServiceImpl.*(..))\"/> &lt;!--执行环绕增加--> &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/> &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/> &lt;/aop:config> 在Log类中实现了MethodBeforeAdvice： @Component public class Log implements MethodBeforeAdvice &#123; //method：要执行的目标对象的方法 //args:参数 //target:目标对象 @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); &#125; &#125; 在AfterLog中实现了AfterReturningAdvice： @Component public class AfterLog implements AfterReturningAdvice &#123; @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(\"执行了\"+method.getName()+\"方法，返回结果为:\"+returnValue); &#125; &#125; 2、自定义切面&lt;!-- 方式二：自定义类--> &lt;bean id=\"diy\" class=\"com.xja.log.Diy\"/> &lt;aop:config> &lt;!--自定义切面，ref要引用的类--> &lt;aop:aspect ref=\"diy\"> &lt;aop:pointcut id=\"point\" expression=\"execution(* com.xja.service.impl.UserServiceImpl.*(..))\"/> &lt;aop:before method=\"before\" pointcut-ref=\"point\"/> &lt;aop:after method=\"after\" pointcut-ref=\"point\"/> &lt;/aop:aspect> &lt;/aop:config> 自定义的切面： public class Diy &#123; public void before()&#123; System.out.println(\"方法执行前\"); &#125; public void after()&#123; System.out.println(\"方法执行后\"); &#125; &#125; 3、注解支持，开启自动代理!&lt;!--方式三--> &lt;!-- 注解支持，开启自动代理! JDK(默认proxy-target-class=\"false\") cglib(默认proxy-target-class=\"true\") --> &lt;aop:aspectj-autoproxy proxy-target-class=\"false\"/> 需要在切面类上加入注解@Aspect，在对应的通知（方法）上注解@Before(“execution(* com.xja.service.impl.UserServiceImpl.*(..))”) @Aspect @Component public class AnnotationPointCut &#123; @Before(\"execution(* com.xja.service.impl.UserServiceImpl.*(..))\") public void before()&#123; System.out.println(\"注解测试，方法执行前\"); &#125; @After(\"execution(* com.xja.service.impl.UserServiceImpl.*(..))\") public void after()&#123; System.out.println(\"注解测试，方法执行后\"); &#125; &#125; 4、切入点表达式语法下面对切入点表达式（也就是expression的配置）的语法进行详细的分析。Spring AOP 用户可能会经常使用 execution切入点指示符。执行表达式的格式如下：execution(public void edu.xja.service.impl.CustomerServiceImpl.*())下面给出一些通用切入点表达式的例子。任意公共方法的执行： execution（public * *（..）） 任何一个名字以“set”开始的方法的执行： execution（* set*（..）） AccountService接口定义的任意方法的执行： execution（* edu.xja.service.AccountService.*（..）） 在service包中定义的任意方法的执行： execution（* edu.xja.service.*.*（..）） 在service包或其子包中定义的任意方法的执行： execution（* edu.xja.service..*.*（..）） 在service包中的任意连接点（在Spring AOP中只是方法执行）： within（edu.xja.service.*） 在service包或其子包中的任意连接点（在Spring AOP中只是方法执行）： within（edu.xja.service..*） 实现了AccountService接口的代理对象的任意连接点 （在Spring AOP中只是方法执行）： this（edu.xja.service.AccountService） ‘this’在绑定表单中更加常用。实现AccountService接口的目标对象的任意连接点 （在Spring AOP中只是方法执行）： target（edu.xja.service.AccountService） ‘target’在绑定表单中更加常用。任何一个只接受一个参数，并且运行时所传入的参数是Serializable 接口的连接点（在Spring AOP中只是方法执行） args（java.io.Serializable） bean（tradeService）任何一个在名字匹配通配符表达式’*Service’的Spring bean之上的连接点 （在Spring AOP中只是方法执行）： bean（*Service）","categories":[],"tags":[]},{"title":"","slug":"8-2 Spring整合Junit","date":"2022-10-23T10:35:00.365Z","updated":"2022-10-23T10:14:13.693Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"&lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.12&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-test&lt;/artifactId> &lt;version>5.3.20&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> 在测试类上加入了注解：@RunWith(SpringJUnit4ClassRunner.class) 【注：此注解是Junit4的】@ExtendWith(SpringExtension.class)【注：此注解是Junit5的】@ContextConfiguration(classes = {SpringConfig.class}) @ExtendWith(SpringExtension.class) @ContextConfiguration(classes = &#123;SpringConfig.class&#125;) public class ApplicationContextTest &#123; @Autowired private StudentService studentService; @Test public void testInit()&#123; //ApplicationContext applicationContext=new AnnotationConfigApplicationContext(SpringConfig.class); //StudentServiceImpl studentService = (StudentServiceImpl) applicationContext.getBean(\"studentServiceImpl\"); studentService.save(); System.out.println(\"program end!!!\"); &#125; &#125; 节省了对 ApplicationContext applicationContext=new AnnotationConfigApplicationContext(SpringConfig.class); StudentServiceImpl studentService = (StudentServiceImpl) applicationContext.getBean(“studentServiceImpl”); 的编写。","categories":[],"tags":[]},{"title":"","slug":"8-1 零配置注解","date":"2022-10-23T10:35:00.361Z","updated":"2022-10-23T10:14:23.486Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1、@Configuration@Configuration主要作为环境启动类。如果没有spring相关xml配置文件，可以自定义一个类，标记注解@Configuration @Configuration public class SpringConfig &#123; public SpringConfig()&#123; System.out.println(\"Spring环境初始化成功!\"); &#125; &#125; 编写测试方法： @Test public void test1()&#123; //@Configuration注解的spring容器加载方式 //用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); &#125; 2、@ComponentScan@ComponentScan注解代替XML配置方式的context:component-scan/标签的作用。用于开启SpringIOC的注解扫描。 @Configuration @ComponentScan(basePackages=&#123;\"edu.xja\"&#125;) //basePackages：可以放置一个或多个包扫描范围，多个包就用“,”隔开 public class SpringConfig &#123; public SpringConfig()&#123; System.out.println(\"Spring环境初始化成功!\"); &#125; &#125; 其他类依然要标记注解@Component @Repository(value=\"customerDao\") public class CustomerDaoImpl implements CustomerDao &#123; @Override public void save() &#123; System.out.println(\"执行了CustomerDaoImpl的save()方法\"); &#125; &#125; 编写测试方法： @Test public void test2()&#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); CustomerDao customerDao = (CustomerDao)ac.getBean(\"customerDao\"); customerDao.save(); &#125; 3、@PropertySource@PropertySource注解，用于代替context:property-placeholader/配置，加载properties配置文件。举例：比如项目中创建了jdbc.properties数据库配置文件，我们可以直接通过springConfig这个类添加注解@PropertySource(value = “classpath:jdbc.properties”)，就能够读取到配置文件中的数据 编写CustomerDao接口 public interface CustomerDao &#123; public void save(); &#125; CustomerDaoImpl，实现类中属性读取值 @Repository(value = \"customerDao\") public class CustomerDaoImpl implements CustomerDao &#123; @Value(\"$&#123;jdbcUrl&#125;\") private String jdbcUrl; @Value(\"$&#123;driverClass&#125;\") private String driverClass; @Value(\"$&#123;user&#125;\") private String user; @Value(\"$&#123;password&#125;\") private String password; @Override public String toString() &#123; return \"CustomerDaoImpl [jdbcUrl=\" + jdbcUrl + \", driverClass=\" + driverClass + \", user=\" + user + \", password=\" + password + \"]\"; &#125; @Override public void save() &#123; System.out.println(\"执行了CustomerDaoImpl的save()方法\"); &#125; &#125; 在resources下新建jdbc.properties文件 jdbcUrl=jdbc:mysql:///spring driverClass=com.mysql.jdbc.Driver user=root password=root springConfig配置类添加注解 @Configuration @ComponentScan(basePackages = &#123;\"edu.xja\"&#125;) @PropertySource(value = \"classpath:jdbc.properties\") //加载jdbc.properties文件，以便@Value注解获取文件值 public class SpringConfig &#123; &#125; 测试： @Test public void test3()&#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); CustomerDao customerDao = (CustomerDao)ac.getBean(\"customerDao\"); System.out.println(customerDao); &#125; 结果： 4、@Import我们将@PropertySource(value = “classpath:jdbc.properties”)分离出来写在新建的JDBCConfig配置类上，然后springConfig类用@Import将JDBCConfig类进行引入，也可同样读取值。CustomerDao接口 public interface CustomerDao &#123; public void save(); &#125; CustomerDaoImpl @Repository(value = \"customerDao\") public class CustomerDaoImpl implements CustomerDao &#123; @Value(\"$&#123;jdbcUrl&#125;\") private String jdbcUrl; @Value(\"$&#123;driverClass&#125;\") private String driverClass; @Value(\"$&#123;user&#125;\") private String user; @Value(\"$&#123;password&#125;\") private String password; @Override public String toString() &#123; return \"CustomerDaoImpl [jdbcUrl=\" + jdbcUrl + \", driverClass=\" + driverClass + \", user=\" + user + \", password=\" + password + \"]\"; &#125; @Override public void save() &#123; System.out.println(\"执行了CustomerDaoImpl的save()方法\"); &#125; &#125; 在resources下新建jdbc.properties文件 jdbcUrl=jdbc:mysql:///spring driverClass=com.mysql.jdbc.Driver user=root password=root 新建JdbcConfig配置类 import org.springframework.context.annotation.PropertySource; @PropertySource(value=\"classpath:jdbc.properties\") public class JdbcConfig &#123; &#125; SpringConfig import edu.xja.config.JdbcConfig; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Import; @Configuration @ComponentScan(basePackages=&#123;\"edu.xja\"&#125;) @Import(JdbcConfig.class) public class SpringConfig &#123; &#125; 注意：SpringConfig类中用了@Import注解，目的是加载另一个配置类JdbcConfig，这样可以实现同时使用多个配置类（类似于XML方式的多个applicationContext.xml）编写测试： @Test public void test3()&#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); CustomerDao customerDao = (CustomerDao)ac.getBean(\"customerDao\"); System.out.println(customerDao); 运行结果： 5、@Bean（使用javaConfig的方式配置Bean）@Bean是一个方法级别上的注解，主要用在@Configuration注解的类里，也可以用在@Component注解的类里。作用是，把方法的返回结果放入IOC容器中，并且起个bean的id名称。@Bean与@Component的区别？ @Component注解的作用是创建一个对象，放入IOC容器中。 @Bean注解并没有创建对象的能力，它只是获取某个方法的返回值，放入IOC容器中。编写Dao接口和实现类CustomerDao接口public interface CustomerDao &#123; public void save(); &#125; CustomerDaoImplimport edu.xja.dao.CustomerDao; import org.springframework.stereotype.Repository; @Repository(value=\"customerDao\") public class CustomerDaoImpl implements CustomerDao &#123; @Override public void save() &#123; System.out.println(\"执行了CustomerDaoImpl的save()方法\"); &#125; &#125; SpringConfig启动类【重点】import edu.xja.dao.CustomerDao; import edu.xja.dao.impl.CustomerDaoImpl; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(basePackages=&#123;\"edu.xja\"&#125;) public class SpringConfig &#123; @Bean(name=\"customerDao\") //获取getCustomerDao的返回对象，放入IOC容器中，并且起名为customerDao public CustomerDao getCustomerDao()&#123; return new CustomerDaoImpl(); &#125; &#125; 注意：在这里@Bean的作用，获取getCustomerDao的返回对象，放入IOC容器中，并且起名为customerDao。测试：public class Demo1 &#123; @Test public void test1()&#123; ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfig.class); CustomerDao customerDao = (CustomerDao)ac.getBean(\"customerDao\"); System.out.println(customerDao); &#125; &#125; 结果：","categories":[],"tags":[]},{"title":"","slug":"8.使用注解开发","date":"2022-10-23T10:35:00.263Z","updated":"2022-10-23T10:15:47.518Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"在Spring4之后，要使用注解开发，必须要保证aop的包导入了使用注解需要导入context约束，增加注解的支持! &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;context:annotation-config/> &lt;/bean> 1.bean2.属性如何注入 @component public class user &#123; public string name; //相当于&lt;property name=\"name\" value=\"kuangshen\" /> @value(\"kuangshen2\") public void setName(String name)&#123; this.name = name; &#125; &#125; 3.衍生的注解@Component有几个衍生注解，我们在web开发中，会按照mvc三层架构分层! dao 【@Repository】 service 【@Service】 controller 【@controller 】 这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean4.自动装配置、 @Autowired :自动装配通过类型。名字 如果Autowired不能唯一自动装配上属性，则需要通过@qualifier(value=\"xxx\") @Nu17able字段标记了这个注解，说明这个字段可以为nu71; @Resource:自动装配通过名字。类型。 5.作用域 @component @scope(\"prototype\") public class user &#123; public string name; //相当于 &lt;property name=\"name \" value=\"kuangshen\" /> @value(\"kuangshen2\") public void setName(string name)&#123; this.name = name; &#125; &#125; 6.小结xml与注解: xml 更加万能，适用于任何场合!维护简单方便。 注解不是自己类使用不了，维护相对复杂! xml与注解最佳实践: xml用来管理bean; 注解只负责完成属性的注入; 我们在使用的过程中，只需要注意一个问题:必须让注解生效，就需要开启注解的支持&lt;! --指定要扫描的包，这个包下的注解就会生效--> &lt;context:component-scan base-package=\"com. kuang\" /> &lt;context:annotation-config/>","categories":[],"tags":[]},{"title":"","slug":"7.Bean的自动装配","date":"2022-10-23T10:35:00.260Z","updated":"2022-10-23T10:14:48.432Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"自动装配是Spring满足bean依赖一种方式! Spring会在上下文中自动寻找，并自动给bean装配属性! 在Spring中有三种装配的方式1.在xml中显示的配置2.在java中显示配置3.隐式的自动装配bean【重要】 7.1、测试环境搭建：一个人有两只宠物！ 7.2、ByName自动装配&lt;!-- byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的 beanid! --> &lt;bean id=\"people\" class=\"com.kuang.pojo.peop1e\" autowire=\"byName\"> &lt;property name=\"name\" value=\"小狂神呀\"/> &lt;/bean> 7.3、ByType自动装配必须保证所装配的属性的类型全局唯一 &lt;!-- byName:会自动在容器上下文中查找，和自己对象属性类型相同的bean! --> &lt;bean id=\"people\" class=\"com.kuang.pojo.peop1e\" autowire=\"byType\"> &lt;property name=\"name\" value=\"小狂神呀\"/> &lt;/bean> 小结： byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致! bytype的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致! 7.4、使用注解实现自动装配jdk1.5支持的注解，Spring2.5就支持注解了！要使用注解须知： 导入约束 配置注解的支持 context:annotation-config 【重要!】&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 开启注解支持--> &lt;context:annotation-config/> &lt;/bean> @Autowired在属性和set方法上使用使用Autowired我们可以不用编写Set方法了，前提是你这个自动装配的属性在IOC(Spring)容器中存在，且符合名字byname!科普： @Nullable 字段标记了这个注解,说明这个字段可以为null; public @interface Autowired &#123; boolean required() default true; &#125; 测试代码 public class People &#123; //如果显示定义了Autowired的required属性为fa1se，说明这个对象可以为null，否则不允许为空 @Autowired(required = false) private cat cat; @Autowired private Dog dog; private String name; &#125; 如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用@Qualifier(value=”xxx”)去配合@Autowired的使用，指定一个唯一的bean对象注入! @Resource注解 小结: @Resource和@Autowired的区别: 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在!【常用】 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现!如果两个都找不到的情况下，就报错!【常用】 执行顺序不同：@Autowired是先 byType 再 byName，@Resource是先 byName 再 byType。","categories":[],"tags":[]},{"title":"","slug":"5、文件上传以及下载","date":"2022-10-23T10:35:00.256Z","updated":"2022-10-23T10:16:13.094Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"SpringMVC提供了MultipartResolver（多部件解析器）接口。MultipartResolver用于处理上传请求，将上传请求包装成可以直接获取文件的数据，从而方便操作。它有两个实现类： StandardServletMultipartResolver：它是Spring3.1版本后的产物，使用Servlet3.0标准的上传方式，不用依赖于第三方包。 CommonsMultipartResolver：使用了Apache的commons-fileupload完成具体的上传操作，可以在Spring的各个版本中使用，需要依赖第三方包才能实现。 下面先学习第二种CommonsMultipartResolver： 1-1、使用CommonsMultipartResolver上传文件导入common-fileupload包&lt;dependency> &lt;groupId>commons-fileupload&lt;/groupId> &lt;artifactId>commons-fileupload&lt;/artifactId> &lt;version>1.4&lt;/version> &lt;/dependency> 配置文件解析器 &lt;!-- 配置文件上传解析器 注意：必须配置id，且名称必须为multipartResolver --> &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"> &lt;!-- 配置限制文件上传大小 (字节为单位)--> &lt;property name=\"maxUploadSize\" value=\"1024000000\"/> &lt;/bean> 注意几个点： 必须配置CommonsMultipartResolver解析器 该解析器的id必须叫multipartResolver，否则无法成功接收文件 可以通过maxUploadSize属性限制文件上传大小 设计文件上传表单、新建test-upload.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>Spring MVC学习-文件上传&lt;/title> &lt;/head> &lt;body> &lt;h3>SpringMVC方式文件上传&lt;/h3> &lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"> 选择文件：&lt;input type=\"file\" name=\"imgFile\"> &lt;br/> 文件描述：&lt;input type=\"text\" name=\"memo\"> &lt;br/> &lt;input type=\"submit\" value=\"上传\"> &lt;/form> &lt;/body> &lt;/html> 上传表单注意以下几点： 表单的enctype必须改为multipart/form-data 表单提交方式必须为POST，不能是GET 编写控制器接收文件及参数/** * 演示Spring MVC文件上传 */ @Controller public class UploadController &#123; /** * 接收文件 */ @RequestMapping(\"/upload\") public String upload(HttpServletRequest request, MultipartFile imgFile, String memo)&#123; //1.获取网站的upload目录的路径： ServletContext对象 String upload = request.getSession().getServletContext().getRealPath(\"/upload\"); //判断该目录是否存在，不存在，自己创建 File uploadFile = new File(upload); if(!uploadFile.exists())&#123; uploadFile.mkdir(); &#125; //把文件保存到upload目录 //2.生成随机文件名称 //2.1 原来的文件名 String oldName = imgFile.getOriginalFilename(); //2.2 随机生成文件名 String uuid = UUID.randomUUID().toString(); //2.3 获取文件后缀 String extName = oldName.substring(oldName.lastIndexOf(\".\")); //.jpg //2.4 最终的文件名 String fileName = uuid+extName; //3.保存 try &#123; imgFile.transferTo(new File(upload+\"/\"+fileName)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"文件描述：\"+memo); return \"success\"; &#125; &#125; 修改pages/success.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>springmvc学习-提示页面&lt;/title> &lt;/head> &lt;body> 上传成功！ &lt;/body> &lt;/html> 检查项目的target目录，是否有文件控制台输出参数内容： 1-2、使用StandardServletMultipartResolver上传文件springmvc.xml 中配置上传文件解析器&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.support.StandardServletMultipartResolver\"> &lt;/bean> 在web.xml配置文件上传的相关配置&lt;multipart-config> &lt;!--临时文件的目录--> &lt;location>d:/&lt;/location> &lt;!-- 上传文件最大2M --> &lt;max-file-size>2097152&lt;/max-file-size> &lt;!-- 上传文件整个请求不超过4M --> &lt;max-request-size>4194304&lt;/max-request-size> &lt;/multipart-config> 上面代码的位置，见下图 要注意xml中web-app节点使用的版本，必须是3.0+。 要注意servlet节点下的multipart-config节点的配置。区别与使用CommonsMultipartResolver进行文件上传时配置的不同。 使用上面相同方法测试即可。 2、文件下载准备下载的文件 设计下载页面新建test-download.jsp &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>Spring MVC 学习-文件下载&lt;/title> &lt;/head> &lt;body> &lt;h3>SpringMVC文件下载&lt;/h3> &lt;a href=\"/down\">下载&lt;/a> &lt;/body> &lt;/html> 编写DownController/** * 演示Spring MVC文件下载 */ @Controller public class DownController &#123; /** * 下载文件 */ @RequestMapping(\"/down\") public void upload(HttpSession session, HttpServletResponse response) throws Exception &#123; //模拟文件下载 //1.读取需要下载的文件 InputStream inputStream = session.getServletContext() .getResourceAsStream(\"/upload/spring.png\"); //2.输出文件 //设置响应头 response.setHeader(\"Content-Disposition\",\"attachment;filename=spring.png\"); OutputStream outputStream = response.getOutputStream(); byte[] buf = new byte[1024]; int len = 0; while( (len = inputStream.read(buf))!=-1 )&#123; outputStream.write(buf,0,len); &#125; //3.关闭资源 outputStream.close(); inputStream.close(); &#125; &#125; 测试：","categories":[],"tags":[]},{"title":"","slug":"4、Spring MVC过滤器-HiddenHttpMethodFilter","date":"2022-10-23T10:35:00.250Z","updated":"2022-10-23T10:16:24.036Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"浏览器form表单只支持GET与POST请求，而DELETE、PUT等method并不支持，spring3.0添加了一个过滤器，可以将这些请求转换为标准的http方法，使得支持GET、POST、PUT与DELETE请求，该过滤器为HiddenHttpMethodFilter。HiddenHttpMethodFilter的父类是OncePerRequestFilter，它继承了父类的doFilterInternal方法，工作原理是将jsp页面的form表单的method属性值在doFilterInternal方法中转化为标准的Http方法，即GET,、POST、 HEAD、OPTIONS、PUT、DELETE、TRACE，然后到Controller中找到对应的方法。 假如在网页中所发出的请求为put、delete，例如： &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>Spring MVC进行RESTful风格开发&lt;/title> &lt;/head> &lt;body> &lt;!--增加 --> &lt;form action=\"/rest\" method=\"post\"> &lt;input type=\"submit\" value=\"增加\"> &lt;/form> &lt;!--查询 --> &lt;form action=\"/rest\" method=\"get\"> &lt;input type=\"submit\" value=\"查询\"> &lt;/form> &lt;!--修改 --> &lt;form action=\"/rest/1\" method=\"post\"> &lt;input type=\"hidden\" name=\"_method\" value=\"put\"> &lt;input type=\"submit\" value=\"修改\"> &lt;/form> &lt;!--删除 --> &lt;form action=\"/rest/1\" method=\"post\"> &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"> &lt;input type=\"submit\" value=\"删除\"> &lt;/form> &lt;/body> &lt;/html> HiddenHttpMethodFilter必须作用于dispatcher前，所以在web.xml中配置HiddenHttpMethodFilter时，需参照如下代码： &lt;!-- 转换请求方式的过滤器 --> &lt;filter> &lt;filter-name>hiddenHttpMethodFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>hiddenHttpMethodFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> 按如下方式写：如何发送PUT请求和DELETE请求？ 需要配置HiddenHttpMethodFilter 需要发送POST请求 需要在发送POST请求时携带一个名称=“_方法”的隐藏域，值为DELETE或PUT","categories":[],"tags":[]},{"title":"","slug":"3-1、Spring MVC开发RESTful应用","date":"2022-10-23T10:35:00.246Z","updated":"2022-10-23T10:16:37.022Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"1、配置请求方式转换过滤器&lt;!-- 转换请求方式的过滤器 --> &lt;filter> &lt;filter-name>hiddenHttpMethodFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>hiddenHttpMethodFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> 2、新建test-restful.jsp&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>Spring MVC进行RESTful风格开发&lt;/title> &lt;/head> &lt;body> &lt;!--增加 --> &lt;form action=\"/rest\" method=\"post\"> &lt;input type=\"submit\" value=\"增加\"> &lt;/form> &lt;!--查询 --> &lt;form action=\"/rest\" method=\"get\"> &lt;input type=\"submit\" value=\"查询\"> &lt;/form> &lt;!--修改 --> &lt;form action=\"/rest/1\" method=\"post\"> &lt;input type=\"hidden\" name=\"_method\" value=\"put\"> &lt;input type=\"submit\" value=\"修改\"> &lt;/form> &lt;!--删除 --> &lt;form action=\"/rest/1\" method=\"post\"> &lt;input type=\"hidden\" name=\"_method\" value=\"delete\"> &lt;input type=\"submit\" value=\"删除\"> &lt;/form> &lt;/body> &lt;/html> 【注】html form method 属性不支持put,delete请求方式 3、控制器接受RestFul请求import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.ResponseBody; /** * 演示RESTful风格的开发 */ @Controller @RequestMapping(\"/rest\") public class RestfulController &#123; /** * 增加 */ @RequestMapping(method= RequestMethod.POST) @ResponseBody public String save()&#123; System.out.println(\"增加...\"); return \"success\"; &#125; /** * 查询 */ @RequestMapping(method= RequestMethod.GET) @ResponseBody public String find()&#123; System.out.println(\"查询...\"); return \"success\"; &#125; /** * 修改 */ @RequestMapping(value = \"/&#123;id&#125;\",method= RequestMethod.PUT) @ResponseBody public String update(@PathVariable(\"id\") Integer id)&#123; System.out.println(\"修改...id=\"+id); return \"success\"; &#125; /** * 删除 */ @RequestMapping(value=\"/&#123;id&#125;\",method= RequestMethod.DELETE) @ResponseBody public String delete(@PathVariable(\"id\") Integer id)&#123; System.out.println(\"删除...id=\"+id); return \"success\"; &#125; &#125; 为了接收RESTful请求，使用method属性指定对应的请求方式 使用@PathVariable注解接收RESTful请求的参数 RESTful风格的请求处理完毕后，通常@ResponseBody注解把数据转换为Json返回，尽量不要转发或重定向页面，因为页面不支持PUT和DELETE请求。4、配置springmvc.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?> &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> &lt;!-- 1.扫描Controller的包--> &lt;context:component-scan base-package=\"edu.xja.controller\"/> &lt;!-- 2.配置视图解析器 --> &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> &lt;!-- 2.1 页面前缀 --> &lt;property name=\"prefix\" value=\"/pages/\"/> &lt;!-- 2.2 页面后缀 --> &lt;property name=\"suffix\" value=\".jsp\"/> &lt;/bean> &lt;!-- 3.注解驱动--> &lt;mvc:annotation-driven /> &lt;!--静态资源处理--> &lt;mvc:default-servlet-handler/> &lt;/beans> 进行测试：分别点击每个按钮，控制台输出效果如下：","categories":[],"tags":[]},{"title":"","slug":"3、RestFul和控制器","date":"2022-10-23T10:35:00.243Z","updated":"2022-10-23T10:16:52.723Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"控制器Controller 控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。 控制器负责解析用户的请求并将其转换为一个模型。 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种实现Controller接口Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；//实现该接口的类获得控制器功能 public interface Controller &#123; //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception; &#125; 测试 新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！ 删掉HelloController mvc的配置文件只留下 视图解析器！ 编写一个Controller类，ControllerTest1 //定义控制器 //注意点：不要导错包，实现Controller接口，重写方法； public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\",\"Test1Controller\"); mv.setViewName(\"test\"); return mv; &#125; &#125; 编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 &lt;bean name=\"/t1\" class=\"com.kuang.controller.ControllerTest1\"/> 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %> &lt;html> &lt;head> &lt;title>Kuangshen&lt;/title> &lt;/head> &lt;body> $&#123;msg&#125; &lt;/body> &lt;/html> 配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！ 说明： 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）； Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。 &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --> &lt;context:component-scan base-package=\"com.kuang.controller\"/> 增加一个ControllerTest2类，使用注解实现； //@Controller注解的类会自动添加到Spring上下文中 @Controller public class ControllerTest2&#123; //映射访问路径 @RequestMapping(\"/t2\") public String index(Model model)&#123; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"ControllerTest2\"); //返回视图位置 return \"test\"; &#125; &#125; 运行tomcat测试 可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。 注解方式是平时使用的最多的方式！ RequestMapping@RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名测试 myweb 只注解在方法上面@Controller public class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125; }访问路径：http://localhost:8080 / 项目名 / h1 同时注解类与方法@Controller @RequestMapping(\"/admin\") public class TestController &#123; @RequestMapping(\"/h1\") public String test()&#123; return \"test\"; &#125; &#125; 访问路径：http://localhost:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径； RestFul 风格概念Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。功能资源：互联网所有的事物都可以被抽象为资源资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。分别对应 添加、 删除、修改、查询。传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get http://127.0.0.1/item/queryItem.action?id=1 查询,GET http://127.0.0.1/item/saveItem.action 新增,POST http://127.0.0.1/item/updateItem.action 更新,POST http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ http://127.0.0.1/item/1 查询,GET http://127.0.0.1/item 新增,POST http://127.0.0.1/item 更新,PUT http://127.0.0.1/item/1 删除,DELETE学习测试 在新建一个类 RestFulController @Controller public class RestFulController &#123; &#125; 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。 @Controller public class RestFulController &#123; //映射访问路径 @RequestMapping(\"/commit/&#123;p1&#125;/&#123;p2&#125;\") public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123; int result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; &#125; &#125; 我们来测试请求查看下 思考：使用路径变量的好处？ 使路径变得更加简洁； 获得参数更加方便，框架会自动进行类型转换。 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。 我们来修改下对应的参数类型，再次测试//映射访问路径 @RequestMapping(\"/commit/&#123;p1&#125;/&#123;p2&#125;\") public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123; String result = p1+p2; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(\"msg\", \"结果：\"+result); //返回视图位置 return \"test\"; &#125; 使用method属性指定请求类型用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等我们来测试一下： 增加一个方法 //映射访问路径,必须是POST请求 @RequestMapping(value = \"/hello\",method = &#123;RequestMethod.POST&#125;) public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\"; &#125; 我们使用浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了； //映射访问路径,必须是Get请求 @RequestMapping(value = \"/hello\",method = &#123;RequestMethod.GET&#125;) public String index2(Model model)&#123; model.addAttribute(\"msg\", \"hello!\"); return \"test\"; &#125; 小结：Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。所有的地址栏请求默认都会是 HTTP GET 类型的。方法级别的注解变体有如下几个：组合注解@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping@GetMapping 是一个组合注解，平时使用的会比较多！它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。","categories":[],"tags":[]},{"title":"集合笔记","slug":"Java-Set-List","date":"2022-04-08T13:54:26.000Z","updated":"2022-04-13T05:39:13.728Z","comments":true,"path":"posts/d1f5r8a4.html","link":"","permalink":"https://shenxiantree.github.io/posts/d1f5r8a4.html","excerpt":"","text":"集合之Set与List区别​ 这段时间对集合（Set）与列表（List）进行的学习，总结了以下的知识点，并对他们之间的差别进行了系统的总结。 1.集合首先我们要知道，集合是工具类，他们都是放在java.util包中。 2.第一大类集合java.util.Collection接口2.1 所有集合的父接口Collection的子接口 java.util.List java.util.Queue(队列) java.util.Set 2.2 子接口java.util.List的实现类： ArrayList(底层使用数组数据结构，在遍历的同时去修改集合的内容要抛出异常） LinkedList(底层使用了链表的数据结构)，同时实现类List和Queue Stack(栈) Vector(线程安全) CopyOnWriteArrayList（可以在遍历集合的同时修改集合中的内容） 2.3 子接口java.util.Queue(队列)的实现类： LinkedList(底层使用了链表的数据结构)，同时实现类List和Queue 2.3 子接口java.util.Set 子接口java.util.Set的子接口SortedSet–实现类TreeSet 子接口java.util.Set的实现类HashSet 子接口java.util.Set的实现类TreeSet 3.第二大类集合java.util.Map接口3.1 集合的父接口java.util.Map接口的子接口为SortedMap–实现类TreeMap 3.2 java.util.Map接口实现类： java.util.HashMap java.util.Hashtable java.util.Properties 4.接口List4.1接口List集合(有序，可以重复)的实现类ArrayList(基于数组实现的，线程不安全，查询效率高) ​ 数组: 有顺序，查询效率高，删除和插入的效率低 4.2接口List的实现类LinkedList(基于链表实现的) ​ 链表: 插入和删除的效率高,查询的效率低 4.3 4. List的实现类Vector(基于数组实现的,线程安全，查询效率比ArrayList低) (尤其需要注意ArrayList与Vector线程的区别) 5.接口Set5.1 接口Set集合(无序，不可以重复), 实现类HashSet（hash算法，hash表和hash桶） 5.2 java.util.Set的子接口SortedSet（可以排序的Set）–实现类TreeSet 5.3 实现类TreeSet,使用树作为数据结构（二叉树，红黑树） 6.工具类Collections的排序方法sort()实现List集合的排序第一个sort方法要求排序的类要实现Comparable接口 从api中看到参数为list集合，不能为set集合 在排序中使用泛型： 第二个sort方法要求排序的创建比较器类，要实现Comparator接口 排序中使用泛型： 7.泛型模板设计`package com.xja.test; import java.util.ArrayList;import java.util.List; /** **手工分页 需要设计一个类PageBean ,泛型的模板设计Listadd(E e) ComparablecompareTo(T o) Comparator compare(T o1, T o2) ** T为占位置的东西，没有任何的含义，也可以写*E **/* public class PageBean { ​ //T-&gt;Student T-&gt;Teacher T-&gt;Book* ​ private int rowCount;*//*总行数 ​ private int pageSize = 5;*//*每页显示的条数 ​ private int page;*//*页码 1,2,3 ​ //当前页的数据 mysql的语法 limit page，pageSize-pageSize,pageSize获取对当前页的数据 ​ //list集合又可以能为tudent分页，也可以为Teacher分页,如果使用下面的设计，不利于扩展 //private List list1; //private List list2; //private List list3; //使用泛型模板的设计，可以提高程序的通用性 private List list;//List List List public static void main(String[] args) { PageBean studentPageBean = new PageBean&lt;&gt;(); *//*模拟从数据库获取的数据 ​ List students = new ArrayList&lt;&gt;(); ​ students.add(new Student(“s001”,”zs”,20));*//*第一页的数据 ​ studentPageBean.list = students; ​ PageBean teacherPageBean = new PageBean&lt;&gt;();​ *//*模拟从数据库获取的数据 ​ List teachers = new ArrayList&lt;&gt;();​ teachers.add(new Teacher(“t001”,”zs”));*//*第一页的数据 ​ teacherPageBean.list = teachers;​ }}` 泛型中的泛型通配符 ？和 ？extends T和 ？super T ` import java.util.ArrayList;import java.util.List; public class TestExtends { public static void main(String[] args) { //Object泛型objectList可以保存Object**的所有子类的类型 List objectList = new ArrayList&lt;&gt;(); objectList.add(“hello”); objectList.add(new Integer(10)); objectList.add(new Double(10.5)); //Number 是 Byte ， Double ， Float ， Integer ， Long ， Short 的父类 List numberList = new ArrayList&lt;&gt;(); numberList.add(new Double(10.5)); numberList.add(new Integer(20)); ​ List integerList = new ArrayList&lt;&gt;();​ integerList.add(new Integer(10));​ integerList.add(new Integer(20)); ​ List doubleList = new ArrayList&lt;&gt;();​ doubleList.add(new Double(10.5));​ doubleList.add(new Double(20.5)); ​ //printCollection1(objectList); ​ //printCollection(numberList); ​ //printCollection(integerList); ​ *//*？ extends Number ?泛型通配符的类型可以是Number的子类和Number本身 ​ printCollection2(integerList);//Number**的子类 ​ printCollection2(doubleList);//Number**的子类 printCollection2(numberList);//Number**自己 //printCollection2(objectList);//Number的父类Object**错误 *//？* super Number *泛型通配符和super ?泛型通配符的类型可以是Number的父类和Number本身* printCollection3(numberList);*//Number自己* //printCollection3(integerList);Number**的子类错误 //printCollection3(doubleList);Number**的子类错误 printCollection3(objectList);//Number的父类Object } `","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://shenxiantree.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"List","slug":"List","permalink":"https://shenxiantree.github.io/tags/List/"},{"name":"Set","slug":"Set","permalink":"https://shenxiantree.github.io/tags/Set/"}],"author":"ShenxianTree"},{"title":"Java数据类型","slug":"Java-Study-1","date":"2022-04-07T13:54:26.000Z","updated":"2022-04-09T07:11:49.875Z","comments":true,"path":"posts/4b7dfd7a.html","link":"","permalink":"https://shenxiantree.github.io/posts/4b7dfd7a.html","excerpt":"","text":"0x001 标识符1.1 标识符的定义&emsp;&emsp;标识符（IDentifier）是指用来标识某个实体的一个符号，简单地说，就是程序中使用的名称 那标识符是如何定义的呢？ 1.2 命名规则 只能由数字字母下划线和$组成，数字不能开头 简短且能清楚地表明它的意义(见名知义) 不能使用JAVA关键字/保留字 区分大小写HelloWord 和 helloword是两个标识符 0x002 变量2.1 变量的定义&emsp;&emsp;内存中一个命名的数据存储空间的名称 2.2 定义的三种方法1.数据类型 变量名; 例如: int age;2.数据类型 变量名 = 变量值; 例如: int age = 23;3.数据类型 变量名1,变量名2,变量名3,…; 例如: int age1,age2,age3; 2.3 变量赋值例如 : age1 = 22;变量必须先定义，然后再使用 0x003 数据类型数据类型总共有两种： 1.基本数据类型： 数值型 整数类型（byte、short、int、long） 浮点类型（flout、double） 字符型（char） 布尔型（boolean） 2.引用数据类型 类（class） 接口（interface） 数组public static void main(String[] args) &#123; String name; int age; name &#x3D; &quot;赵丽丽&quot; ; age &#x3D; 22; double score &#x3D; 98.5; char sex &#x3D; &#39;女&#39;; System.out.println(&quot;姓名:&quot;+name); System.out.println(&quot;年龄:&quot;+age); System.out.println(&quot;成绩:&quot;+score); System.out.println(&quot;性别:&quot;+sex); &#125; 0x004 运算符1.算术运算符 2.赋值运算符 例：定义变量保存成绩信息，计算总成绩和平均成绩，并输出 public static void main(String[] args) &#123; String name &#x3D;&quot;赵丽丽&quot;; double yw_score &#x3D; 98.5; int sx_score &#x3D; 98; int yy_score&#x3D;77; double zh_score &#x3D; yw_score+sx_score+yy_score; double pj_score &#x3D; zh_score &#x2F;3; System.out.println(name +&quot;的成绩表&quot;); System.out.println(&quot;姓名:&quot;); System.out.println(&quot;语文\\t数学\\t英语\\t总分\\t平均分&quot;); System.out.println(yw_score+&quot;\\t&quot;+sx_score+&quot;\\t&quot;+yy_score+&quot;\\t&quot;+zh_score+&quot;\\t&quot;+pj_score); &#125; 定义一个变量保存一个四位数,计算得出个十百千四个位上的数字并计算总和 public static void main(String[] args) &#123; int num &#x3D; 1234; int gewei &#x3D; num%10; int shiwei &#x3D; num&#x2F;10%10; int baiwei &#x3D; num&#x2F;100%10; int qianwei &#x3D; num&#x2F;1000; int zonghe &#x3D; gewei+shiwei+baiwei+qianwei; System.out.println(&quot;四位数字之和是:&quot;+zonghe); &#125; 参考朱老师教案","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://shenxiantree.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://shenxiantree.github.io/tags/Java/"},{"name":"数据类型","slug":"数据类型","permalink":"https://shenxiantree.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"author":"ShenxianTree"},{"title":"Java入门","slug":"Java-Study","date":"2022-04-07T13:53:00.000Z","updated":"2022-04-08T02:02:07.267Z","comments":true,"path":"posts/null.html","link":"","permalink":"https://shenxiantree.github.io/posts/null.html","excerpt":"","text":"0x001 Java语言是什么？&emsp;&emsp;Java是一种计算机语言, 通过编译和运行能实现人机交流，人类可以指挥电脑，Java是一种高级开发语言，安全，便捷，跨平台，符合当前人类的思维方式，Java是现在使用人数最多，潜力最强的语言。 0x002 Java编译的过程语言分为高级语言和机器语言。机器语言：计算机可以认识的语言(0 和1)高级语言：开发者理解的语言，if print高级语言开发者认识，计算机不认识。将高级语言编写的代码（源代码）通过手段转换机器语言。 手段只有二种：==编译和翻译（解释）==高级划分为两类：编译型语言解释型语言编译：源代码—整体将源代码编译的过程—可执行的文件解释：源代码—通过解释器，一行一行解释给计算机执行。 0x003 java的版本： Java的版本从jdk1.0到现在的jdk1.12，1.4 java1.5( java5.0 ) , java6.0 java7.0 java8.0 （1.8） java在java1.2版本进行了模块划分：j2SE(标准版) , j2EE（企业版，WEB网络应用） , j2ME（移动平台） J2SE(Java 2 Platform Standard Edition) 标准版 J2SE是Java的标准版，J2SE包含了Java的核心类库，主要用于开发客户端（桌面应用软件），例如常用的文本编辑器、下载软件、即时通讯工具等，都可以通过J2SE实现。 从JDK5.0开始， J2SE改名为Java SE 当然，学习Java编程就是从J2SE入手J2EE(Java 2 Platform Enterprise Edition) 企业版J2EE是功能最丰富的一个版本，主要用于开发高访问量、大数据量、高并发量的网站，例如美团、去哪儿网的后台都是J2EE。通常所说的JSP 开发就是J2EE的一部分。 J2ME(Java 2 Platform Micro Edition) 微型版J2ME 只包含J2SE中的一部分类，受平台影响比较大，主要用于嵌入式系统和移动平台的开发，例如手机（功能机）、机顶盒等。在智能手机还没有进入公众视野的时候，你是否还记得你的摩托罗拉、诺基亚手机上有很多Java小游戏吗？这就是用J2ME开发的。 0x004 第一个Java程序Java的第一个程序 helloworld。Java源文件，就是一个单纯的文本文件。步骤1：创建一个名称叫Test.java的源文件步骤2：在源文件中编写类-class public class Test&#123; public static void main(String[] args)&#123; System.out.println(&quot;hello! World！&quot;); &#125; &#125; 参考朱老师教案","categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://shenxiantree.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://shenxiantree.github.io/tags/Java/"},{"name":"编程","slug":"编程","permalink":"https://shenxiantree.github.io/tags/%E7%BC%96%E7%A8%8B/"}],"author":"ShenxianTree"},{"title":"Hello World","slug":"hello-world","date":"2022-01-26T09:21:42.055Z","updated":"2022-01-26T09:21:42.055Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"https://shenxiantree.github.io/posts/undefined.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"文字背景粒子特效","slug":"jQuery+CSS3","date":"2020-03-26T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"posts/4b3510a4.html","link":"","permalink":"https://shenxiantree.github.io/posts/4b3510a4.html","excerpt":"","text":"前言一款jQuery+CSS3的文字背景粒子动画特效，一共6种粒子效果，每种文字背景的粒子效果都不同，有漂浮的有坠落的等等。 0x001 特效演示 This is fires This is lines This is hearts This is bubbles This is confetti This is sunbeams .particletext { } .fire > .particle { position: absolute; background-color: rgba(255, 193, 7, 0.5); border-radius: 40px; border-top-right-radius: 0px; -webkit-animation: fires 0.8s linear infinite; animation: fires 0.8s linear infinite; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); opacity: 0; } /*css keyframes 动画*/ @-webkit-keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } @keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } function fire() { $.each($(\".particletext.fire\"), function(){ var firecount = ($(this).width()/50)*20; for(var i = 0; i .particle { position: absolute; background-color: rgba(244, 67, 54, 0.5); -webkit-animation: lines 3s linear infinite; animation: lines 3s linear infinite; } @-webkit-keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } @keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } function lines() { $.each($(\".particletext.lines\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: #cc2a5d; -webkit-animation: hearts 3s ease-in infinite; animation: hearts 3s ease-in infinite; } .hearts > .particle:before,.hearts > .particle:after { position: absolute; content: ''; border-radius: 100px; top: 0px; left: 0px; width: 100%; height: 100%; background-color: #cc2a5d; } .hearts > .particle:before { -webkit-transform: translateX(-50%); transform: translateX(-50%); } .hearts > .particle:after { -webkit-transform: translateY(-50%); transform: translateY(-50%); } @-webkit-keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } @keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } function hearts() { $.each($(\".particletext.hearts\"), function(){ var heartcount = ($(this).width()/50)*5; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: rgba(33, 150, 243, 0.5); -webkit-animation: bubbles 3s ease-in infinite; animation: bubbles 3s ease-in infinite; border-radius: 100%; } @-webkit-keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } @keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } function bubbles() { $.each($(\".particletext.bubbles\"), function(){ var bubblecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; -webkit-animation: confetti 3s ease-in infinite; animation: confetti 3s ease-in infinite; } .confetti > .particle.c1 { background-color: rgba(76, 175, 80, 0.5); } .confetti > .particle.c2 { background-color: rgba(156, 39, 176, 0.5); } @-webkit-keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } @keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } function confetti() { $.each($(\".particletext.confetti\"), function(){ var confetticount = ($(this).width()/50)*10; for(var i = 0; i .particle { position: absolute; background-color: rgba(253, 216, 53, 0.5); -webkit-animation: sunbeams 3s linear infinite; animation: sunbeams 3s linear infinite; } @-webkit-keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } @keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } function sunbeams() { $.each($(\".particletext.sunbeams\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i function fire() &#123; $.each($(\".particletext.fire\"), function()&#123; var firecount = ($(this).width()/50)*20; for(var i = 0; i &lt;= firecount; i++) &#123; var size = $.rnd(8,12); $(this).append('&lt;span class=\"particle\" style=\"top:' + $.rnd(40,70) + '%; left:' + $.rnd(-10,100) + '%;width:' + size + 'px; height:' + size + 'px;animation-delay: ' + ($.rnd(0,20)/10) + 's;\">&lt;/span>'); &#125; &#125;); &#125; jQuery.rnd = function(m,n) &#123; m = parseInt(m); n = parseInt(n); return Math.floor( Math.random() * (n - m + 1) ) + m; &#125; fire(); &lt;/script> 2. CSS 代码&lt;style> .fire > .particle &#123; position: absolute; background-color: rgba(255, 193, 7, 0.5); border-radius: 40px; border-top-right-radius: 0px; -webkit-animation: fires 0.8s linear infinite; animation: fires 0.8s linear infinite; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); opacity: 0; &#125; @-webkit-keyframes fires &#123; 0% &#123; -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); &#125; 25% &#123; -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; &#125; 50% &#123; -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); &#125; 75% &#123; -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); &#125; 100% &#123; -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; &#125; &#125; @keyframes fires &#123; 0% &#123; -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); &#125; 25% &#123; -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; &#125; 50% &#123; -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); &#125; 75% &#123; -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); &#125; 100% &#123; -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; &#125; &#125; &lt;/style> 3. HTML 代码&lt;div style=\"width: 100%;text-align: center; height: 120px; position: relative; bottom: 0px;\" > &lt;span class=\"particletext fire\" style=\"font-size:48px;position: relative;\">This is fires&lt;/span> &lt;/div> 0x003 Lines 特效1. JS 代码&lt;script> function lines() &#123; $.each($(\".particletext.lines\"), function()&#123; var linecount = ($(this).width()/50)*10; for(var i = 0; i &lt;= linecount; i++) &#123; $(this).append('&lt;span class=\"particle\" style=\"top:' + $.rnd(-30,30) + '%; left:' + $.rnd(-10,110) + '%;width:' + $.rnd(1,3) + 'px; height:' + $.rnd(20,80) + '%;animation-delay: -' + ($.rnd(0,30)/10) + 's;\">&lt;/span>'); &#125; &#125;); &#125; jQuery.rnd = function(m,n) &#123; m = parseInt(m); n = parseInt(n); return Math.floor( Math.random() * (n - m + 1) ) + m; &#125; lines(); &lt;/script> 2. CSS 代码&lt;style> .lines > .particle &#123; position: absolute; background-color: rgba(244, 67, 54, 0.5); -webkit-animation: lines 3s linear infinite; animation: lines 3s linear infinite; &#125; @-webkit-keyframes lines &#123; 0%, 50%, 100% &#123; -webkit-transform: translateY(0%); transform: translateY(0%); &#125; 25% &#123; -webkit-transform: translateY(100%); transform: translateY(100%); &#125; 75% &#123; -webkit-transform: translateY(-100%); transform: translateY(-100%); &#125; &#125; @keyframes lines &#123; 0%, 50%, 100% &#123; -webkit-transform: translateY(0%); transform: translateY(0%); &#125; 25% &#123; -webkit-transform: translateY(100%); transform: translateY(100%); &#125; 75% &#123; -webkit-transform: translateY(-100%); transform: translateY(-100%); &#125; &#125; &lt;/style> 3. HTML 代码&lt;div style=\"width: 100%;text-align: center; height: 120px; position: relative; bottom: 0px;\" > &lt;span class=\"particletext lines\" style=\"font-size:48px; position: relative;\">This is lines&lt;/span> &lt;/div> 0x004 Hearts 特效1. JS 代码&lt;script> function hearts() &#123; $.each($(\".particletext.hearts\"), function()&#123; var heartcount = ($(this).width()/50)*5; for(var i = 0; i &lt;= heartcount; i++) &#123; var size = ($.rnd(60,120)/10); $(this).append('&lt;span class=\"particle\" style=\"top:' + $.rnd(20,80) + '%; left:' + $.rnd(0,95) + '%;width:' + size + 'px; height:' + size + 'px;animation-delay: ' + ($.rnd(0,30)/10) + 's;\">&lt;/span>'); &#125; &#125;); &#125; jQuery.rnd = function(m,n) &#123; m = parseInt(m); n = parseInt(n); return Math.floor( Math.random() * (n - m + 1) ) + m; &#125; hearts(); &lt;/script> 2. CSS 代码&lt;style> .hearts > .particle &#123; opacity: 0; position: absolute; background-color: #cc2a5d; -webkit-animation: hearts 3s ease-in infinite; animation: hearts 3s ease-in infinite; &#125; .hearts > .particle:before, .hearts > .particle:after &#123; position: absolute; content: ''; border-radius: 100px; top: 0px; left: 0px; width: 100%; height: 100%; background-color: #cc2a5d; &#125; .hearts > .particle:before &#123; -webkit-transform: translateX(-50%); transform: translateX(-50%); &#125; .hearts > .particle:after &#123; -webkit-transform: translateY(-50%); transform: translateY(-50%); &#125; @-webkit-keyframes hearts &#123; 0% &#123; opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); &#125; 20% &#123; opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); &#125; 100% &#123; opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); &#125; &#125; @keyframes hearts &#123; 0% &#123; opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); &#125; 20% &#123; opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); &#125; 100% &#123; opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); &#125; &#125; &lt;/style> 3. HTML 代码&lt;div style=\"width: 100%;text-align: center; height: 120px; position: relative; bottom: 0px;\" > &lt;span class=\"particletext hearts\" style=\"font-size:48px; position: relative;\">This is hearts&lt;/span> &lt;/div> 0x005 Bubbles 特效1. JS 代码&lt;script> function bubbles() &#123; $.each($(\".particletext.bubbles\"), function()&#123; var bubblecount = ($(this).width()/50)*10; for(var i = 0; i &lt;= bubblecount; i++) &#123; var size = ($.rnd(40,80)/10); $(this).append('&lt;span class=\"particle\" style=\"top:' + $.rnd(20,80) + '%; left:' + $.rnd(0,95) + '%;width:' + size + 'px; height:' + size + 'px;animation-delay: ' + ($.rnd(0,30)/10) + 's;\">&lt;/span>'); &#125; &#125;); &#125; jQuery.rnd = function(m,n) &#123; m = parseInt(m); n = parseInt(n); return Math.floor( Math.random() * (n - m + 1) ) + m; &#125; bubbles(); &lt;/script> 2. CSS 代码&lt;style> &lt;style> .bubbles > .particle &#123; opacity: 0; position: absolute; background-color: rgba(33, 150, 243, 0.5); -webkit-animation: bubbles 3s ease-in infinite; animation: bubbles 3s ease-in infinite; border-radius: 100%; &#125; @-webkit-keyframes bubbles &#123; 0% &#123; opacity: 0; &#125; 20% &#123; opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); &#125; 100% &#123; opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); &#125; &#125; @keyframes bubbles &#123; 0% &#123; opacity: 0; &#125; 20% &#123; opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); &#125; 100% &#123; opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); &#125; &#125; &lt;/style> 3. HTML 代码&lt;div style=\"width: 100%;text-align: center; height: 120px; position: relative; bottom: 0px;\" > &lt;span class=\"particletext bubbles\" style=\"font-size:48px; position: relative;\">This is bubbles&lt;/span> &lt;/div> 0x006 Confetti 特效1. JS 代码&lt;script> function confetti() &#123; $.each($(\".particletext.confetti\"), function()&#123; var confetticount = ($(this).width()/50)*10; for(var i = 0; i &lt;= confetticount; i++) &#123; $(this).append('&lt;span class=\"particle c' + $.rnd(1,2) + '\" style=\"top:' + $.rnd(10,50) + '%; left:' + $.rnd(0,100) + '%;width:' + $.rnd(6,8) + 'px; height:' + $.rnd(3,4) + 'px;animation-delay: ' + ($.rnd(0,30)/10) + 's;\">&lt;/span>'); &#125; &#125;); &#125; jQuery.rnd = function(m,n) &#123; m = parseInt(m); n = parseInt(n); return Math.floor( Math.random() * (n - m + 1) ) + m; &#125; confetti(); &lt;/script> 2. CSS 代码&lt;style> .confetti > .particle &#123; opacity: 0; position: absolute; -webkit-animation: confetti 3s ease-in infinite; animation: confetti 3s ease-in infinite; &#125; .confetti > .particle.c1 &#123; background-color: rgba(76, 175, 80, 0.5); &#125; .confetti > .particle.c2 &#123; background-color: rgba(156, 39, 176, 0.5); &#125; @-webkit-keyframes confetti &#123; 0% &#123; opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); &#125; 10% &#123; opacity: 1; &#125; 35% &#123; -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); &#125; 80% &#123; opacity: 1; &#125; 100% &#123; opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); &#125; &#125; @keyframes confetti &#123; 0% &#123; opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); &#125; 10% &#123; opacity: 1; &#125; 35% &#123; -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); &#125; 80% &#123; opacity: 1; &#125; 100% &#123; opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); &#125; &#125; &lt;/style> 3. HTML 代码&lt;div style=\"width: 100%;text-align: center; height: 120px; position: relative; bottom: 0px;\" > &lt;span class=\"particletext confetti\" style=\"font-size:48px; position: relative;\">This is confetti&lt;/span> &lt;/div> 0x007 Sunbeams 特效1. JS 代码&lt;script> function sunbeams() &#123; $.each($(\".particletext.sunbeams\"), function()&#123; var linecount = ($(this).width()/50)*10; for(var i = 0; i &lt;= linecount; i++) &#123; $(this).append('&lt;span class=\"particle\" style=\"top:' + $.rnd(-50,00) + '%; left:' + $.rnd(0,100) + '%;width:' + $.rnd(1,3) + 'px; height:' + $.rnd(80,160) + '%;animation-delay: -' + ($.rnd(0,30)/10) + 's;\">&lt;/span>'); &#125; &#125;); &#125; jQuery.rnd = function(m,n) &#123; m = parseInt(m); n = parseInt(n); return Math.floor( Math.random() * (n - m + 1) ) + m; &#125; sunbeams(); &lt;/script> 2. CSS 代码&lt;style> .sunbeams > .particle &#123; position: absolute; background-color: rgba(253, 216, 53, 0.5); -webkit-animation: sunbeams 3s linear infinite; animation: sunbeams 3s linear infinite; &#125; @-webkit-keyframes sunbeams &#123; 0% &#123; -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); &#125; 50% &#123; -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); &#125; 100% &#123; -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); &#125; 0%,14%,17%,43%,53%,71%,80%,94%,100% &#123; opacity: 0; &#125; 6%,15%,24%,28%,48%,55%,78%,82%,99% &#123; opacity: 1; &#125; &#125; @keyframes sunbeams &#123; 0% &#123; -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); &#125; 50% &#123; -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); &#125; 100% &#123; -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); &#125; 0%,14%,17%,43%,53%,71%,80%,94%,100% &#123; opacity: 0; &#125; 6%,15%,24%,28%,48%,55%,78%,82%,99% &#123; opacity: 1; &#125; &#125; &lt;/style> 3. HTML 代码&lt;div style=\"width: 100%;text-align: center; height: 120px; position: relative; bottom: 0px;\" > &lt;span class=\"particletext sunbeams\" style=\"font-size:48px; position: relative;\">This is sunbeams&lt;/span> &lt;/div>","categories":[{"name":"前端篇","slug":"前端篇","permalink":"https://shenxiantree.github.io/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"jQuery+CSS3","slug":"jQuery-CSS3","permalink":"https://shenxiantree.github.io/tags/jQuery-CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"https://shenxiantree.github.io/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"}],"author":"Luckey"},{"title":"PicGo+GitHub 图床搭建","slug":"PicGo-GitHub","date":"2020-03-14T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"posts/7a46f93c.html","link":"","permalink":"https://shenxiantree.github.io/posts/7a46f93c.html","excerpt":"","text":"前言用GitHub搭建图床，在很久之前我就有了解，但由于市面上有挺多免费的图床，比如我之前一直在用的 路过图床，所以一直懒得动手搭建GitHub图床。一直到前两天我在完善博客的相册时，发现 路过图床 免费版的有这么多限制，比如：每小时限制上传50张图片，每天限制上传100张图片，而且免费版用户的存储容量貌似不过300M，这才意识到有一个自己的GitHub图床是多么重要。 0x001 PicGO 介绍PicGo是一款图片上传工具，目前支持 SM.MS图床、腾讯云COS、GitHub图床、七牛图床、Imgur图床、阿里云OSS、又拍云图床，未来将支持更多图床。 在支持的这些图床中，SM.MS和Imgur有免费版和收费版，免费版的肯定有很多的使用限制，比如每小时限制上传次数，限制用户的上传容量等等；腾讯云COS、阿里云、有拍云都是要收费使用的；七牛云貌似前期使用免费，后期又要收费才能使用，就剩下的GitHub才是免费且最可靠的。 PicGo源项目GitHub地址已给出，但是去GitHub下载速度非常慢，这里额外提供一个蓝奏云的快速下载地址。 GitHub地址：https://github.com/Molunerfinn/PicGo 蓝奏云地址：https://luckyzmj.lanzous.com/id3e0id 0x002 GitHub 图床1. 创建GitHub图床仓库首先需要有一个登录GitHub的账号，没有的话去GitHub官网注册一个 创建一个新的图床仓库，点击右上角的New repository 填写如下配置信息，然后Create创建仓库 2. 获取GitHub token值点击右上的头像，选择设置Setting 点击选择Developer settings 点击 Generate New token 填写如下配置信息，只要勾选repo选项即可，然后页面拉到底部点击Generate token 即可 此时会跳转到带有token的页面，将token值复制记录下来，之后用PicGo绑定GitHub图床时会利用到 0x003 PicGo 配置1. 绑定GitHub图床首先下载安装好PicGo软件，然后在右列表找到GitHub图床配置 1. 设定仓库名(必填)： 按照“GitHub账户名/仓库名的格式填写”，比如我的是：Luckyzmj/imgbed 2. 设定分支名(必填)： 仓库分支名填写”master”或者”main”，视情况而定。因为GitHub 官方表示,从2020年10月1日起,在该平台上创建的所有新的源代码仓库将默认被命名为”main”,而不是原先的”master”。 3. 设定Token(必填)： 将之前步骤的Token值复制粘贴到这里 4. 指定存储路径： 这个选项可以为空，如果想将图片上传到仓库的指定目录下，可以填写目录名加/，比如我的imgbed仓库下有个posts文件夹，需设置为 posts/ 5. 设定自定义域名： 这里统一用jsdelivr的CDN加速域名，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接 自定义域名格式：https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;GitHub账户名&#x2F;仓库名 以我的格式为例：https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Luckyzmj&#x2F;imgbed 配置完全部信息后，点击 设为默认图床，最后点击确定即可 2. 上传图片到图床在上传区上传图片，可支持本地图片上传(可多选图片)、剪贴板上传、URL上传等三种方式。上传图片成功后，选择你想要生成的图片链接格式 在图片区，可以看到成功上传的图片，选择相应的图片进行操作即可 3. PicGo 注意事项如果配置完PicGo后却上传图片失败，可以参考以下方法： 检查自定义域名是否正确 仓库名不要有空格 图片名字不要带有特殊符号，如：%、+、*、空格等 建议开启时间戳重命名，防止图片名字重复 上传图片间歇太短，需在PicGo设置中关闭Server选项 PicGo应用不稳定因素，需重启应用 参考文章 https://blog.csdn.net/sunhwee/article/details/100109956","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://shenxiantree.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://shenxiantree.github.io/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"https://shenxiantree.github.io/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"Luckey"}],"categories":[{"name":"技术篇","slug":"技术篇","permalink":"https://shenxiantree.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AF%87/"},{"name":"前端篇","slug":"前端篇","permalink":"https://shenxiantree.github.io/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"},{"name":"博客篇","slug":"博客篇","permalink":"https://shenxiantree.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"List","slug":"List","permalink":"https://shenxiantree.github.io/tags/List/"},{"name":"Set","slug":"Set","permalink":"https://shenxiantree.github.io/tags/Set/"},{"name":"Java","slug":"Java","permalink":"https://shenxiantree.github.io/tags/Java/"},{"name":"数据类型","slug":"数据类型","permalink":"https://shenxiantree.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"编程","slug":"编程","permalink":"https://shenxiantree.github.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"jQuery+CSS3","slug":"jQuery-CSS3","permalink":"https://shenxiantree.github.io/tags/jQuery-CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"https://shenxiantree.github.io/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"},{"name":"PicGo","slug":"PicGo","permalink":"https://shenxiantree.github.io/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"https://shenxiantree.github.io/tags/GitHub%E5%9B%BE%E5%BA%8A/"}]}